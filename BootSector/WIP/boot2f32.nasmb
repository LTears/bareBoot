;------------------------------------------------------------------------------
;*
;*   Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
;*   This program and the accompanying materials
;*   are licensed and made available under the terms and conditions of the BSD License
;*   which accompanies this distribution.  The full text of the license may be found at
;*   http://opensource.org/licenses/bsd-license.php
;*
;*   THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
;*   WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
;*
;*    boot2f32.nasmb
;*
;*   Abstract:
;*
;------------------------------------------------------------------------------

        BITS 16

FAT_DIRECTORY_ENTRY_SIZE    EQU     020h
FAT_DIRECTORY_ENTRY_SHIFT   EQU     5
BLOCK_SIZE                  EQU     0200h
BLOCK_MASK                  EQU     01FFh
BLOCK_SHIFT                 EQU     9

        org 0h
Ia32Jump:
  jmp   BootSectorEntryPoint  ; JMP inst    - 3 bytes
  nop

OemId               db  "INTEL   "    ; OemId                           - 8 bytes
SectorSize          dw  0             ; Sector Size                     - 2 bytes
SectorsPerCluster   db  0             ; Sector Per Cluster              - 1 byte
ReservedSectors     dw  0             ; Reserved Sectors                - 2 bytes
NoFats              db  0             ; Number of FATs                  - 1 byte
RootEntries         dw  0             ; Root Entries                    - 2 bytes
Sectors             dw  0             ; Number of Sectors               - 2 bytes
Media               db  0             ; Media                           - 1 byte
SectorsPerFat16     dw  0             ; Sectors Per FAT for FAT12/FAT16 - 2 byte
SectorsPerTrack     dw  0             ; Sectors Per Track               - 2 bytes
Heads               dw  0             ; Heads                           - 2 bytes
HiddenSectors       dd  0             ; Hidden Sectors                  - 4 bytes
LargeSectors        dd  0             ; Large Sectors                   - 4 bytes

;******************************************************************************
;
;The structure for FAT32 starting at offset 36 of the boot sector. (At this point,
;the BPB/boot sector for FAT12 and FAT16 differs from the BPB/boot sector for FAT32.)
;
;******************************************************************************

SectorsPerFat32     dd  0             ; Sectors Per FAT for FAT32       - 4 bytes
ExtFlags            dw  0             ; Mirror Flag                     - 2 bytes
FSVersion           dw  0             ; File System Version             - 2 bytes
RootCluster         dd  0             ; 1st Cluster Number of Root Dir  - 4 bytes
FSInfo              dw  0             ; Sector Number of FSINFO         - 2 bytes
BkBootSector        dw  0             ; Sector Number of Bk BootSector  - 2 bytes
Reserved            times 12 db 0     ; Reserved Field                  - 12 bytes
PhysicalDrive       db  0             ; Physical Drive Number           - 1 byte
Reserved1           db  0             ; Reserved Field                  - 1 byte
Signature           db  0             ; Extended Boot Signature         - 1 byte
VolId               db  "    "        ; Volume Serial Number            - 4 bytes
FatLabel            db  "           " ; Volume Label                    - 11 bytes
FileSystemType      db  "FAT32   "    ; File System Type                - 8 bytes

BootSectorEntryPoint:
      ; ds = 1000, es = 2000 + x (size of first cluster >> 4)
      ; cx = Start Cluster of EfiLdr
      ; dx = Start Cluster of Efivar.bin

; Re use the BPB data stored in Boot Sector
        mov     bp, 07C00h

        push    cx
; Read Efivar.bin
;       1000:dx    = DirectoryEntry of Efivar.bin -> BS.com has filled already
        mov     ax, 01900h
        mov     es, ax
        test    dx, dx
        jnz     CheckVarStoreSize

        mov     al, 1
NoVarStore:
        push    es
; Set the 5th byte start @ 0:19000 to non-zero indicating we should init var store header in DxeIpl
        mov     byte [es:4], al
        jmp     SaveVolumeId

CheckVarStoreSize:
        mov     di, dx
        cmp     dword [di + 2], 04000h
        mov     al, 2
        jne     NoVarStore

LoadVarStore:
        mov     al, 0
        mov     byte [es:4], al
        mov     cx, word [di]
;       ES:DI = 1500:0
        xor     di, di
        push    es
        mov     ax, 01500h
        mov     es, ax
        call    ReadFile
SaveVolumeId:
        pop     es
        mov     ax, word [bp + VolId]
        mov     word [es:0], ax                  ; Save Volume Id to 0:19000. we will find the correct volume according to this VolumeId
        mov     ax, word [bp + VolId + 2]
        mov     word [es:2], ax

; Read Efildr
        pop     cx
;       cx    = Start Cluster of Efildr -> BS.com has filled already
;       ES:DI = 2000:0, first cluster will be read again
        xor     di, di                               ; di = 0
        mov     ax, 02000h
        mov     es, ax
        call    ReadFile
        mov     ax, cs
        mov     word [cs:JumpSegment], ax

CheckEm64T:
        mov  eax, 080000001h
        cpuid
        bt   edx, 29
        jc   CheckEm64TPass
        push cs
        pop  ds
        lea  si, [Em64String]
        mov  cx, 18
        jmp  PrintStringAndHalt

CheckEm64TPass:

JumpFarInstruction:
        db      0eah
JumpOffset:
        dw      0200h
JumpSegment:
        dw      2000h

; ****************************************************************************
; ReadFile
;
; Arguments:
;   CX    = Start Cluster of File
;   ES:DI = Buffer to store file content read from disk
;
; Return:
;   (ES << 4 + DI) = end of file content Buffer
;
; ****************************************************************************
ReadFile:
; si      = NumberOfClusters
; cx      = ClusterNumber
; dx      = CachedFatSectorNumber
; ds:0000 = CacheFatSectorBuffer
; es:di   = Buffer to load file
; bx      = NextClusterNumber
        pusha
        mov     si, 1                           ; NumberOfClusters = 1
        push    cx                              ; Push Start Cluster onto stack
        mov     dx, 0FFFh                       ; CachedFatSectorNumber = 0xfff
FatChainLoop:
        mov     ax, cx                          ; ax = ClusterNumber
        and     ax, 0FFF8h                      ; ax = ax & 0xfff8
        cmp     ax, 0FFF8h                      ; See if this is the last cluster
        je      FoundLastCluster                ; Jump if last cluster found
        mov     ax, cx                          ; ax = ClusterNumber
        shl     ax, 2                           ; FatOffset = ClusterNumber * 4
        push    si                              ; Save si
        mov     si, ax                          ; si = FatOffset
        shr     ax, BLOCK_SHIFT                 ; ax = FatOffset >> BLOCK_SHIFT
        add     ax, word [bp + ReservedSectors] ; ax = FatSectorNumber = ReservedSectors + (FatOffset >> BLOCK_OFFSET)
        and     si, BLOCK_MASK                  ; si = FatOffset & BLOCK_MASK
        cmp     ax, dx                          ; Compare FatSectorNumber to CachedFatSectorNumber
        je      SkipFatRead
        mov     bx, 2
        push    es
        push    ds
        pop     es
        call    ReadBlocks                      ; Read 2 blocks starting at AX storing at ES:DI
        pop     es
        mov     dx, ax                          ; CachedFatSectorNumber = FatSectorNumber
SkipFatRead:
        mov     bx, word [si]                   ; bx = NextClusterNumber
        mov     ax, cx                          ; ax = ClusterNumber
        pop     si                              ; Restore si
        dec     bx                              ; bx = NextClusterNumber - 1
        cmp     bx, cx                          ; See if (NextClusterNumber-1)==ClusterNumber
        jne     ReadClusters
        inc     bx                              ; bx = NextClusterNumber
        inc     si                              ; NumberOfClusters + +
        mov     cx, bx                          ; ClusterNumber = NextClusterNumber
        jmp     FatChainLoop
ReadClusters:
        inc     bx
        pop     ax                              ; ax = StartCluster
        push    bx                              ; StartCluster = NextClusterNumber
        mov     cx, bx                          ; ClusterNumber = NextClusterNumber
        sub     ax, 2                           ; ax = StartCluster - 2
        xor     bh, bh
        mov     bl, byte [bp + SectorsPerCluster] ; bx = SectorsPerCluster
        mul     bx                              ; ax = (StartCluster - 2) * SectorsPerCluster
        add     ax, word [bp]                   ; ax = FirstClusterLBA + (StartCluster-2)*SectorsPerCluster
        push    ax                              ; save start sector
        mov     ax, si                          ; ax = NumberOfClusters
        mul     bx                              ; ax = NumberOfClusters * SectorsPerCluster
        mov     bx, ax                          ; bx = Number of Sectors
        pop     ax                              ; ax = Start Sector
        call    ReadBlocks
        mov     si, 1                           ; NumberOfClusters = 1
        jmp     FatChainLoop
FoundLastCluster:
        pop     cx
        popa
        ret

; ****************************************************************************
; ReadBlocks - Reads a set of blocks from a block device
;
; AX    = Start LBA
; BX    = Number of Blocks to Read
; ES:DI = Buffer to store sectors read from disk
; ****************************************************************************

; cx = Blocks
; bx = NumberOfBlocks
; si = StartLBA

ReadBlocks:
        pusha
        add     eax, dword [bp + LBAOffsetForBootSector] ; Add LBAOffsetForBootSector to Start LBA
        add     eax, dword [bp + HiddenSectors] ; Add HiddenSectors to Start LBA
        mov     esi, eax                        ; esi = Start LBA
        mov     cx, bx                          ; cx = Number of blocks to read
ReadCylinderLoop:
        mov     bp, 07bfch                      ; bp = 0x7bfc
        mov     eax, esi                        ; eax = Start LBA
        xor     edx, edx                        ; edx = 0
        movzx   ebx, word [bp]                  ; bx = MaxSector
        div     ebx                             ; ax = StartLBA / MaxSector
        inc     dx                              ; dx = (StartLBA % MaxSector) + 1

        mov     bx, word [bp]                   ; bx = MaxSector
        sub     bx, dx                          ; bx = MaxSector - Sector
        inc     bx                              ; bx = MaxSector - Sector + 1
        cmp     cx, bx                          ; Compare (Blocks) to (MaxSector - Sector + 1)
        jg      LimitTransfer
        mov     bx, cx                          ; bx = Blocks
LimitTransfer:
        push    ax                              ; save ax
        mov     ax, es                          ; ax = es
        shr     ax, (BLOCK_SHIFT-4)             ; ax = Number of blocks into mem system
        and     ax, 07fh                        ; ax = Number of blocks into current seg
        add     ax, bx                          ; ax = End Block number of transfer
        cmp     ax, 080h                        ; See if it crosses a 64K boundry
        jle     NotCrossing64KBoundry           ; Branch if not crossing 64K boundry
        sub     ax, 080h                        ; ax = Number of blocks past 64K boundry
        sub     bx, ax                          ; Decrease transfer size by block overage
NotCrossing64KBoundry:
        pop     ax                              ; restore ax

        push    cx
        mov     cl, dl                          ; cl = (StartLBA % MaxSector) + 1 = Sector
        xor     dx, dx                          ; dx = 0
        div     word [bp + 2]                   ; ax = ax / (MaxHead + 1) = Cylinder
                                                ; dx = ax % (MaxHead + 1) = Head

        push    bx                              ; Save number of blocks to transfer
        mov     dh, dl                          ; dh = Head
        mov     bp, 07c00h                      ; bp = 0x7c00
        mov     dl, byte [bp + PhysicalDrive]   ; dl = Drive Number
        mov     ch, al                          ; ch = Cylinder
        mov     al, bl                          ; al = Blocks
        mov     ah, 2                           ; ah = Function 2
        mov     bx, di                          ; es:bx = Buffer address
        int     013h
        jc      DiskError
        pop     bx
        pop     cx
        movzx   ebx, bx
        add     esi, ebx                        ; StartLBA = StartLBA + NumberOfBlocks
        sub     cx, bx                          ; Blocks = Blocks - NumberOfBlocks
        mov     ax, es
        shl     bx, (BLOCK_SHIFT - 4)
        add     ax, bx
        mov     es, ax                          ; es:di = es:di + NumberOfBlocks*BLOCK_SIZE
        cmp     cx, 0
        jne     ReadCylinderLoop
        popa
        ret

DiskError:
        push cs
        pop  ds
        lea  si, [ErrorString]
        mov  cx, 7
        jmp  PrintStringAndHalt

PrintStringAndHalt:
        mov  ax, 0B800h
        mov  es, ax
        mov  di, 160
        rep  movsw
Halt:
        jmp   Halt

ErrorString:
        db 'S', 0ch, 'E', 0ch, 'r', 0ch, 'r', 0ch, 'o', 0ch, 'r', 0ch, '!', 0ch

;???        org     01fah
        times (01FAh - ($ - $$)) db 0
LBAOffsetForBootSector:
        dd      0h

;???        org     01feh
        times (01FEh - ($ - $$)) db 0
        dw      0aa55h
