;------------------------------------------------------------------------------
;*
;*   Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
;*   This program and the accompanying materials
;*   are licensed and made available under the terms and conditions of the BSD License
;*   which accompanies this distribution.  The full text of the license may be found at
;*   http://opensource.org/licenses/bsd-license.php
;*
;*   THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
;*   WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
;*
;*    st32_32.nasmb
;*
;*   Abstract:
;*
;------------------------------------------------------------------------------

        BITS 16

DELAY_PORT           equ     0edh    ; Port to use for 1uS delay
KBD_CONTROL_PORT     equ     060h    ; 8042 control port
KBD_STATUS_PORT      equ     064h    ; 8042 status port
WRITE_DATA_PORT_CMD  equ     0d1h    ; 8042 command to write the data port
ENABLE_A20_CMD       equ     0dfh    ; 8042 command to enable A20

;???        org     200h
	times (0200h - ($ - $$)) db 0
        jmp start
Em64String:
        db 'E', 0ch, 'm', 0ch, '6', 0ch, '4', 0ch, 'T', 0ch, ' ', 0ch, 'U', 0ch, 'n', 0ch, 's', 0ch, 'u', 0ch, 'p', 0ch, 'p', 0ch, 'o', 0ch, 'r', 0ch, 't', 0ch, 'e', 0ch, 'd', 0ch, '!', 0ch

start:
        mov ax, cs
        mov ds, ax
        mov es, ax
        mov ss, ax
        mov sp, MyStack

;        mov ax, 0b800h
;        mov es, ax
;        mov byte [es:160], 'a'
;        mov ax, cs
;        mov es, ax

        mov ebx, 0
        lea edi, [MemoryMap]
MemMapLoop:
        mov eax, 0e820h
        mov ecx, 20
        mov edx, 'SMAP'
        int 15h
        jc  MemMapDone
        add edi, 20
        cmp ebx, 0
        je  MemMapDone
        jmp MemMapLoop
MemMapDone:
        lea eax, [MemoryMap]
        sub edi, eax                         ; Get the address of the memory map
        mov dword [MemoryMapSize], edi   ; Save the size of the memory map

        xor     ebx, ebx
        mov     bx, cs                       ; BX=segment
        shl     ebx, 4                       ; BX="linear" address of segment base
        lea     eax, [GDT_BASE + ebx]        ; EAX=PHYSICAL address of gdt
        mov     dword [gdtr + 2], eax    ; Put address of gdt into the gdtr
        lea     eax, [IDT_BASE + ebx]        ; EAX=PHYSICAL address of idt
        mov     dword [idtr + 2], eax    ; Put address of idt into the idtr
        lea     edx, [MemoryMapSize + ebx]   ; Physical base address of the memory map

        add ebx, 01000h                      ; Source of EFI32
        mov dword [JUMP + 2], ebx
        add ebx, 01000h
        mov esi, ebx                         ; Source of EFILDR32

;        mov ax, 0b800h
;        mov es, ax
;        mov byte [es:162], 'b'
;        mov ax, cs
;        mov es, ax

; Enable A20 Gate

        mov ax, 2401h                        ; Enable A20 Gate
        int 15h
        jnc A20GateEnabled                  ; Jump if it suceeded

; If INT 15 Function 2401 is not supported, then attempt to Enable A20 manually.

        call    Empty8042InputBuffer        ; Empty the Input Buffer on the 8042 controller
        jnz     Timeout8042                 ; Jump if the 8042 timed out
        out     DELAY_PORT, ax               ; Delay 1 uS
        mov     al, WRITE_DATA_PORT_CMD      ; 8042 cmd to write output port
        out     KBD_STATUS_PORT, al          ; Send command to the 8042
        call    Empty8042InputBuffer        ; Empty the Input Buffer on the 8042 controller
        jnz     Timeout8042                 ; Jump if the 8042 timed out
        mov     al, ENABLE_A20_CMD           ; gate address bit 20 on
        out     KBD_CONTROL_PORT, al         ; Send command to thre 8042
        call    Empty8042InputBuffer        ; Empty the Input Buffer on the 8042 controller
        mov     cx, 25                       ; Delay 25 uS for the command to complete on the 8042
Delay25uS:
        out     DELAY_PORT, ax               ; Delay 1 uS
        loop    Delay25uS
Timeout8042:


A20GateEnabled:
        mov     bx, 0008h                    ; Flat data descriptor

; DISABLE INTERRUPTS - Entering Protected Mode

        cli

;        mov ax, 0b800h
;        mov es, ax
;        mov byte [es:164], 'c'
;        mov ax, cs
;        mov es, ax

        db      66h
        o32 lgdt    [dword gdtr]
        db      66h
        o32 lidt    [dword idtr]

        mov     eax, cr0
        or      al, 1
        mov     cr0, eax
JUMP:
; jmp far 0010:00020000
        db  066h
        db  0eah
        dd  000020000h
        dw  00010h

Empty8042InputBuffer:
        xor cx, cx
Empty8042Loop:
        out     DELAY_PORT, ax               ; Delay 1us
        in      al, KBD_STATUS_PORT          ; Read the 8042 Status Port
        and     al, 02h                      ; Check the Input Buffer Full Flag
        loopnz  Empty8042Loop               ; Loop until the input buffer is empty or a timout of 65536 uS
        ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; data
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        align 02h

gdtr    dw GDT_END - GDT_BASE - 1   ; GDT limit
        dd 0                        ; (GDT base gets set above)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;   global descriptor table (GDT)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        align 02h

GDT_BASE:

; null descriptor
NULL_SEL            equ $-GDT_BASE	; Selector [0x0]
        dw 0            ; limit 15:0
        dw 0            ; base 15:0
        db 0            ; base 23:16
        db 0            ; type
        db 0            ; limit 19:16, flags
        db 0            ; base 31:24

; linear data segment descriptor
LINEAR_SEL      equ $-GDT_BASE		; Selector [0x8]
        dw 0FFFFh       ; limit 0xFFFFF
        dw 0            ; base 0
        db 0
        db 092h         ; present, ring 0, data, expand-up, writable
        db 0CFh                 ; page-granular, 32-bit
        db 0

; linear code segment descriptor
LINEAR_CODE_SEL equ $-GDT_BASE		; Selector [0x10]
        dw 0FFFFh       ; limit 0xFFFFF
        dw 0            ; base 0
        db 0
        db 09Ah         ; present, ring 0, data, expand-up, writable
        db 0CFh                 ; page-granular, 32-bit
        db 0

; system data segment descriptor
SYS_DATA_SEL    equ $-GDT_BASE		; Selector [0x18]
        dw 0FFFFh       ; limit 0xFFFFF
        dw 0            ; base 0
        db 0
        db 092h         ; present, ring 0, data, expand-up, writable
        db 0CFh                 ; page-granular, 32-bit
        db 0

; system code segment descriptor
SYS_CODE_SEL    equ $-GDT_BASE		; Selector [0x20]
        dw 0FFFFh       ; limit 0xFFFFF
        dw 0            ; base 0
        db 0
        db 09Ah         ; present, ring 0, data, expand-up, writable
        db 0CFh                 ; page-granular, 32-bit
        db 0

; spare segment descriptor
SPARE3_SEL  equ $-GDT_BASE		; Selector [0x28]
        dw 0            ; limit 0xFFFFF
        dw 0            ; base 0
        db 0
        db 0            ; present, ring 0, data, expand-up, writable
        db 0            ; page-granular, 32-bit
        db 0

; spare segment descriptor
SPARE4_SEL  equ $-GDT_BASE		; Selector [0x30]
        dw 0            ; limit 0xFFFFF
        dw 0            ; base 0
        db 0
        db 0            ; present, ring 0, data, expand-up, writable
        db 0            ; page-granular, 32-bit
        db 0

; spare segment descriptor
SPARE5_SEL  equ $-GDT_BASE		; Selector [0x38]
        dw 0            ; limit 0xFFFFF
        dw 0            ; base 0
        db 0
        db 0            ; present, ring 0, data, expand-up, writable
        db 0            ; page-granular, 32-bit
        db 0

GDT_END:

        align 02h

idtr    dw IDT_END - IDT_BASE - 1   ; IDT limit
        dd 0                        ; (IDT base gets set above)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;   interrupt descriptor table (IDT)
;
;   Note: The hardware IRQ's specified in this table are the normal PC/AT IRQ
;       mappings.  This implementation only uses the system timer and all other
;       IRQs will remain masked.  The descriptors for vectors 33 + are provided
;       for convenience.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        align 02h

IDT_BASE:

; divide by zero (INT 0)
DIV_ZERO_SEL        equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; debug exception (INT 1)
DEBUG_EXCEPT_SEL    equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; NMI (INT 2)
NMI_SEL             equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; soft breakpoint (INT 3)
BREAKPOINT_SEL      equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; overflow (INT 4)
OVERFLOW_SEL        equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; bounds check (INT 5)
BOUNDS_CHECK_SEL    equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; invalid opcode (INT 6)
INVALID_OPCODE_SEL  equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; device not available (INT 7)
DEV_NOT_AVAIL_SEL   equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; double fault (INT 8)
DOUBLE_FAULT_SEL    equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; Coprocessor segment overrun - reserved (INT 9)
RSVD_INTR_SEL1      equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; invalid TSS (INT 0ah)
INVALID_TSS_SEL     equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; segment not present (INT 0bh)
SEG_NOT_PRESENT_SEL equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; stack fault (INT 0ch)
STACK_FAULT_SEL     equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; general protection (INT 0dh)
GP_FAULT_SEL        equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; page fault (INT 0eh)
PAGE_FAULT_SEL      equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; Intel reserved - do not use (INT 0fh)
RSVD_INTR_SEL2      equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; floating point error (INT 10h)
FLT_POINT_ERR_SEL   equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; alignment check (INT 11h)
ALIGNMENT_CHECK_SEL equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; (10001110)type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; machine check (INT 12h)
MACHINE_CHECK_SEL   equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; (10001110)type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; SIMD floating-point exception (INT 13h)
SIMD_EXCEPTION_SEL  equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; (10001110)type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; 85 unspecified descriptors, First 12 of them are reserved, the rest are avail
        times (85 * 8) db 0

; IRQ 0 (System timer) - (INT 68h)
IRQ0_SEL            equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; (10001110)type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; IRQ 1 (8042 Keyboard controller) - (INT 69h)
IRQ1_SEL            equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; (10001110)type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; Reserved - IRQ 2 redirect (IRQ 2) - DO NOT USE!!! - (INT 6ah)
IRQ2_SEL            equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; (10001110)type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; IRQ 3 (COM 2) - (INT 6bh)
IRQ3_SEL            equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; (10001110)type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; IRQ 4 (COM 1) - (INT 6ch)
IRQ4_SEL            equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; (10001110)type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; IRQ 5 (LPT 2) - (INT 6dh)
IRQ5_SEL            equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; (10001110)type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; IRQ 6 (Floppy controller) - (INT 6eh)
IRQ6_SEL            equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; (10001110)type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; IRQ 7 (LPT 1) - (INT 6fh)
IRQ7_SEL            equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; (10001110)type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; IRQ 8 (RTC Alarm) - (INT 70h)
IRQ8_SEL            equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; (10001110)type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; IRQ 9 - (INT 71h)
IRQ9_SEL            equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; (10001110)type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; IRQ 10 - (INT 72h)
IRQ10_SEL            equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; (10001110)type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; IRQ 11 - (INT 73h)
IRQ11_SEL            equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; (10001110)type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; IRQ 12 (PS/2 mouse) - (INT 74h)
IRQ12_SEL            equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; (10001110)type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; IRQ 13 (Floating point error) - (INT 75h)
IRQ13_SEL            equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; (10001110)type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; IRQ 14 (Secondary IDE) - (INT 76h)
IRQ14_SEL            equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; (10001110)type = 386 interrupt gate, present
        dw 0            ; offset 31:16

; IRQ 15 (Primary IDE) - (INT 77h)
IRQ15_SEL            equ $-IDT_BASE
        dw 0            ; offset 15:0
        dw SYS_CODE_SEL ; selector 15:0
        db 0            ; 0 for interrupt gate
        db 0eh | 80h   ; (10001110)type = 386 interrupt gate, present
        dw 0            ; offset 31:16

IDT_END:

        align 02h

MemoryMapSize:
	dd  0

MemoryMap:

;???        org 0fe0h
	times (0FE0h - ($ - $$)) db 0

MyStack:
        ; below is the pieces of the IVT that is used to redirect INT 68h - 6fh
        ;    back to INT 08h - 0fh  when in real mode...  It is 'org'ed to a
        ;    known low address (20f00) so it can be set up by PlMapIrqToVect in
        ;    8259.c

        int 8
        iret

        int 9
        iret

        int 10
        iret

        int 11
        iret

        int 12
        iret

        int 13
        iret

        int 14
        iret

        int 15
        iret


;???        org 0ffeh
	times (0FFEh - ($ - $$)) db 0
BlockSignature:
        dw  0aa55h
