Index: DuetPkg/DuetPkg.dec
===================================================================
--- DuetPkg/DuetPkg.dec	(revision 1)
+++ DuetPkg/DuetPkg.dec	(working copy)
@@ -28,6 +28,7 @@
   gEfiPciExpressBaseAddressGuid = {0x3677d529, 0x326f, 0x4603, {0xa9, 0x26, 0xea, 0xac, 0xe0, 0x1d, 0xcb, 0xb0 }}
   gEfiAcpiDescriptionGuid       = {0x3c699197, 0x093c, 0x4c69, {0xb0, 0x6b, 0x12, 0x8a, 0xe3, 0x48, 0x1d, 0xc9 }}
   gEfiFlashMapHobGuid           = { 0xb091e7d2, 0x5a0, 0x4198, {0x94, 0xf0, 0x74, 0xb7, 0xb8, 0xc5, 0x54, 0x59 }}
+  gUefiDuetPkgTokenSpaceGuid    = {0x6bfe6b51, 0x5834, 0x4d79, {0xdf, 0xc1, 0x44, 0x1d, 0x7a, 0x69, 0x8b, 0xcd }}
   
   ## Include/Guid/PciOptionRomTable.h
   gEfiPciOptionRomTableGuid     = { 0x7462660F, 0x1CBD, 0x48DA, { 0xAD, 0x11, 0x91, 0x71, 0x79, 0x13, 0x83, 0x1C }}
@@ -40,3 +41,9 @@
 
   ## Include/Guid/LdrMemoryDescriptor.h
   gLdrMemoryDescriptorGuid      = { 0x7701d7e5, 0x7d1d, 0x4432, { 0xa4, 0x68, 0x67, 0x3d, 0xab, 0x8a, 0xde, 0x60 }}
+
+[PcdsDynamic, PcdsDynamicEx]
+  gUefiDuetPkgTokenSpaceGuid.PcdEmuVariableEvent|0|UINT64|2
+
+[PcdsFeatureFlag]
+  gUefiDuetPkgTokenSpaceGuid.PcdSecureBootEnable|FALSE|BOOLEAN|3
Index: DuetPkg/DuetPkg.fdf
===================================================================
--- DuetPkg/DuetPkg.fdf	(revision 1)
+++ DuetPkg/DuetPkg.fdf	(working copy)
@@ -51,7 +51,6 @@
 INF  MdeModulePkg/Core/RuntimeDxe/RuntimeDxe.inf
 INF  MdeModulePkg/Universal/MonotonicCounterRuntimeDxe/MonotonicCounterRuntimeDxe.inf
 
-INF  DuetPkg/FSVariable/FSVariable.inf
 INF  MdeModulePkg/Universal/CapsuleRuntimeDxe/CapsuleRuntimeDxe.inf
 INF  MdeModulePkg/Universal/MemoryTest/NullMemoryTestDxe/NullMemoryTestDxe.inf
 INF  MdeModulePkg/Universal/SecurityStubDxe/SecurityStubDxe.inf
Index: DuetPkg/DuetPkgX64.dsc
===================================================================
--- DuetPkg/DuetPkgX64.dsc	(revision 4)
+++ DuetPkg/DuetPkgX64.dsc	(working copy)
@@ -182,7 +182,6 @@
   MdeModulePkg/Core/RuntimeDxe/RuntimeDxe.inf
   MdeModulePkg/Universal/MonotonicCounterRuntimeDxe/MonotonicCounterRuntimeDxe.inf
 
-  DuetPkg/FSVariable/FSVariable.inf
   MdeModulePkg/Universal/CapsuleRuntimeDxe/CapsuleRuntimeDxe.inf
   MdeModulePkg/Universal/MemoryTest/NullMemoryTestDxe/NullMemoryTestDxe.inf
   MdeModulePkg/Universal/SecurityStubDxe/SecurityStubDxe.inf
Index: DuetPkg/EmuVariableFvbRuntimeDxe/Fvb.c
===================================================================
--- DuetPkg/EmuVariableFvbRuntimeDxe/Fvb.c	(revision 0)
+++ DuetPkg/EmuVariableFvbRuntimeDxe/Fvb.c	(working copy)
@@ -0,0 +1,939 @@
+/** @file
+  Firmware Block Services to support emulating non-volatile variables
+  by pretending that a memory buffer is storage for the NV variables.
+
+  Copyright (c) 2006 - 2013, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "PiDxe.h"
+#include <Guid/EventGroup.h>
+#include <Guid/SystemNvDataGuid.h>
+#include <Guid/VariableFormat.h>
+
+#include <Protocol/FirmwareVolumeBlock.h>
+#include <Protocol/DevicePath.h>
+
+#include <Library/UefiLib.h>
+#include <Library/UefiDriverEntryPoint.h>
+#include <Library/BaseLib.h>
+#include <Library/UefiRuntimeLib.h>
+#include <Library/DebugLib.h>
+#include <Library/BaseMemoryLib.h>
+#include <Library/MemoryAllocationLib.h>
+#include <Library/UefiBootServicesTableLib.h>
+#include <Library/DevicePathLib.h>
+#include <Library/PcdLib.h>
+#include <Library/PlatformFvbLib.h>
+#include <Library/DxeServicesTableLib.h>
+#include "Fvb.h"
+
+#define EFI_AUTHENTICATED_VARIABLE_GUID \
+{ 0xaaf32c78, 0x947b, 0x439a, { 0xa1, 0x80, 0x2e, 0x14, 0x4e, 0xc3, 0x77, 0x92 } }
+
+//
+// Virtual Address Change Event
+//
+// This is needed for runtime variable access.
+//
+EFI_EVENT   mEmuVarsFvbAddrChangeEvent = NULL;
+
+//
+// This is the single instance supported by this driver.  It
+// supports the FVB and Device Path protocols.
+//
+EFI_FW_VOL_BLOCK_DEVICE mEmuVarsFvb = {
+  FVB_DEVICE_SIGNATURE,
+  {     // DevicePath
+    {
+      {
+        HARDWARE_DEVICE_PATH,
+        HW_MEMMAP_DP,
+        {
+          sizeof (MEMMAP_DEVICE_PATH),
+          0
+        }
+      },
+      EfiMemoryMappedIO,
+      0,
+      0,
+    },
+    {
+      END_DEVICE_PATH_TYPE,
+      END_ENTIRE_DEVICE_PATH_SUBTYPE,
+      {
+        sizeof (EFI_DEVICE_PATH_PROTOCOL),
+        0
+      }
+    }
+  },
+  NULL, // BufferPtr
+  FixedPcdGet32 (PcdFlashNvStorageFtwSpareSize), // BlockSize
+  2 * FixedPcdGet32 (PcdFlashNvStorageFtwSpareSize), // Size
+  {     // FwVolBlockInstance
+    FvbProtocolGetAttributes,
+    FvbProtocolSetAttributes,
+    FvbProtocolGetPhysicalAddress,
+    FvbProtocolGetBlockSize,
+    FvbProtocolRead,
+    FvbProtocolWrite,
+    FvbProtocolEraseBlocks,
+    NULL
+  },
+};
+
+
+/**
+  Notification function of EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE.
+
+  This is a notification function registered on EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE event.
+  It converts pointer to new virtual address.
+
+  @param  Event        Event whose notification function is being invoked.
+  @param  Context      Pointer to the notification function's context.
+
+**/
+VOID
+EFIAPI
+FvbVirtualAddressChangeEvent (
+  IN EFI_EVENT        Event,
+  IN VOID             *Context
+  )
+{
+  DEBUG ((EFI_D_ERROR, "-----------------EfiConvertPointer\n"));
+  EfiConvertPointer (0x0, &mEmuVarsFvb.BufferPtr);
+}
+
+
+//
+// FVB protocol APIs
+//
+
+/**
+  The GetPhysicalAddress() function retrieves the base address of
+  a memory-mapped firmware volume. This function should be called
+  only for memory-mapped firmware volumes.
+
+  @param This     Indicates the EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL instance.
+  
+  @param Address  Pointer to a caller-allocated
+                  EFI_PHYSICAL_ADDRESS that, on successful
+                  return from GetPhysicalAddress(), contains the
+                  base address of the firmware volume.
+  
+  @retval EFI_SUCCESS       The firmware volume base address is returned.
+  
+  @retval EFI_NOT_SUPPORTED The firmware volume is not memory mapped.
+
+**/
+EFI_STATUS
+EFIAPI
+FvbProtocolGetPhysicalAddress (
+  IN CONST  EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL *This,
+  OUT       EFI_PHYSICAL_ADDRESS                *Address
+  )
+{
+  EFI_FW_VOL_BLOCK_DEVICE *FvbDevice;
+
+  FvbDevice = FVB_DEVICE_FROM_THIS (This);
+
+  *Address = (EFI_PHYSICAL_ADDRESS)(UINTN) FvbDevice->BufferPtr;
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  The GetBlockSize() function retrieves the size of the requested
+  block. It also returns the number of additional blocks with
+  the identical size. The GetBlockSize() function is used to
+  retrieve the block map (see EFI_FIRMWARE_VOLUME_HEADER).
+
+
+  @param This           Indicates the EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL instance.
+
+  @param Lba            Indicates the block for which to return the size.
+
+  @param BlockSize      Pointer to a caller-allocated UINTN in which
+                        the size of the block is returned.
+
+  @param NumberOfBlocks Pointer to a caller-allocated UINTN in
+                        which the number of consecutive blocks,
+                        starting with Lba, is returned. All
+                        blocks in this range have a size of
+                        BlockSize.
+
+  
+  @retval EFI_SUCCESS             The firmware volume base address is returned.
+  
+  @retval EFI_INVALID_PARAMETER   The requested LBA is out of range.
+
+**/
+EFI_STATUS
+EFIAPI
+FvbProtocolGetBlockSize (
+  IN CONST  EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL *This,
+  IN        EFI_LBA                             Lba,
+  OUT       UINTN                               *BlockSize,
+  OUT       UINTN                               *NumberOfBlocks
+  )
+{
+  EFI_FW_VOL_BLOCK_DEVICE *FvbDevice;
+
+  if (Lba > 1) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  FvbDevice = FVB_DEVICE_FROM_THIS (This);
+
+  *BlockSize = FvbDevice->BlockSize;
+  *NumberOfBlocks = (UINTN) (2 - (UINTN) Lba);
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  The GetAttributes() function retrieves the attributes and
+  current settings of the block. Status Codes Returned
+
+  @param This       Indicates the EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL instance.
+
+  @param Attributes Pointer to EFI_FVB_ATTRIBUTES_2 in which the
+                    attributes and current settings are
+                    returned. Type EFI_FVB_ATTRIBUTES_2 is defined
+                    in EFI_FIRMWARE_VOLUME_HEADER.
+
+  @retval EFI_SUCCESS The firmware volume attributes were
+                      returned.
+
+**/
+EFI_STATUS
+EFIAPI
+FvbProtocolGetAttributes (
+  IN CONST  EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL *This,
+  OUT       EFI_FVB_ATTRIBUTES_2                *Attributes
+  )
+{
+  *Attributes =
+    (EFI_FVB_ATTRIBUTES_2) (
+      EFI_FVB2_READ_ENABLED_CAP |
+      EFI_FVB2_READ_STATUS |
+      EFI_FVB2_WRITE_ENABLED_CAP |
+      EFI_FVB2_WRITE_STATUS |
+      EFI_FVB2_ERASE_POLARITY
+      );
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  The SetAttributes() function sets configurable firmware volume
+  attributes and returns the new settings of the firmware volume.
+
+  @param This         Indicates the EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL instance.
+
+  @param Attributes   On input, Attributes is a pointer to
+                      EFI_FVB_ATTRIBUTES_2 that contains the
+                      desired firmware volume settings. On
+                      successful return, it contains the new
+                      settings of the firmware volume. Type
+                      EFI_FVB_ATTRIBUTES_2 is defined in
+                      EFI_FIRMWARE_VOLUME_HEADER.
+  
+  @retval EFI_SUCCESS           The firmware volume attributes were returned.
+
+  @retval EFI_INVALID_PARAMETER The attributes requested are in
+                                conflict with the capabilities
+                                as declared in the firmware
+                                volume header.
+
+**/
+EFI_STATUS
+EFIAPI
+FvbProtocolSetAttributes (
+  IN CONST  EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL *This,
+  IN OUT    EFI_FVB_ATTRIBUTES_2                *Attributes
+  )
+{
+  return EFI_ACCESS_DENIED;
+}
+
+
+/**
+  Erases and initializes a firmware volume block.
+
+  The EraseBlocks() function erases one or more blocks as denoted
+  by the variable argument list. The entire parameter list of
+  blocks must be verified before erasing any blocks. If a block is
+  requested that does not exist within the associated firmware
+  volume (it has a larger index than the last block of the
+  firmware volume), the EraseBlocks() function must return the
+  status code EFI_INVALID_PARAMETER without modifying the contents
+  of the firmware volume. Implementations should be mindful that
+  the firmware volume might be in the WriteDisabled state. If it
+  is in this state, the EraseBlocks() function must return the
+  status code EFI_ACCESS_DENIED without modifying the contents of
+  the firmware volume. All calls to EraseBlocks() must be fully
+  flushed to the hardware before the EraseBlocks() service
+  returns.
+
+  @param This   Indicates the EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL
+                instance.
+
+  @param ...    The variable argument list is a list of tuples.
+                Each tuple describes a range of LBAs to erase
+                and consists of the following:
+                - An EFI_LBA that indicates the starting LBA
+                - A UINTN that indicates the number of blocks to
+                  erase
+
+                The list is terminated with an
+                EFI_LBA_LIST_TERMINATOR. For example, the
+                following indicates that two ranges of blocks
+                (5-7 and 10-11) are to be erased: EraseBlocks
+                (This, 5, 3, 10, 2, EFI_LBA_LIST_TERMINATOR);
+
+  @retval EFI_SUCCESS The erase request was successfully
+                      completed.
+  
+  @retval EFI_ACCESS_DENIED   The firmware volume is in the
+                              WriteDisabled state.
+  @retval EFI_DEVICE_ERROR  The block device is not functioning
+                            correctly and could not be written.
+                            The firmware device may have been
+                            partially erased.
+  @retval EFI_INVALID_PARAMETER One or more of the LBAs listed
+                                in the variable argument list do
+                                not exist in the firmware volume.  
+
+**/
+EFI_STATUS
+EFIAPI
+FvbProtocolEraseBlocks (
+  IN CONST  EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL *This,
+  ...
+  )
+{
+  EFI_FW_VOL_BLOCK_DEVICE *FvbDevice;
+  VA_LIST                 args;
+  EFI_LBA                 StartingLba;
+  UINTN                   NumOfLba;
+  UINT8                   Erase;
+  VOID                    *ErasePtr;
+  UINTN                   EraseSize;
+
+  FvbDevice = FVB_DEVICE_FROM_THIS (This);
+  Erase = 0;
+
+  VA_START (args, This);
+
+  do {
+    StartingLba = VA_ARG (args, EFI_LBA);
+    if (StartingLba == EFI_LBA_LIST_TERMINATOR) {
+      break;
+    }
+
+    NumOfLba = VA_ARG (args, UINT32);
+
+    //
+    // Check input parameters
+    //
+    if ((NumOfLba == 0) || (StartingLba > 1) || ((StartingLba + NumOfLba) > 2)) {
+      VA_END (args);
+      return EFI_INVALID_PARAMETER;
+    }
+
+    if (StartingLba == 0) {
+      Erase = (UINT8) (Erase | BIT0);
+    }
+    if ((StartingLba + NumOfLba) == 2) {
+      Erase = (UINT8) (Erase | BIT1);
+    }
+
+  } while (1);
+
+  VA_END (args);
+
+  ErasePtr = (UINT8*) FvbDevice->BufferPtr;
+  EraseSize = 0;
+
+  if ((Erase & BIT0) != 0) {
+    EraseSize = EraseSize + FvbDevice->BlockSize;
+  } else {
+    ErasePtr = (VOID*) ((UINT8*)ErasePtr + FvbDevice->BlockSize);
+  }
+
+  if ((Erase & BIT1) != 0) {
+    EraseSize = EraseSize + FvbDevice->BlockSize;
+  }
+
+  if (EraseSize != 0) {
+    SetMem (
+      (VOID*) ErasePtr,
+      EraseSize,
+      ERASED_UINT8
+      );
+    VA_START (args, This);
+    PlatformFvbBlocksErased (This, args);
+    VA_END (args);
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Writes the specified number of bytes from the input buffer to the block.
+
+  The Write() function writes the specified number of bytes from
+  the provided buffer to the specified block and offset. If the
+  firmware volume is sticky write, the caller must ensure that
+  all the bits of the specified range to write are in the
+  EFI_FVB_ERASE_POLARITY state before calling the Write()
+  function, or else the result will be unpredictable. This
+  unpredictability arises because, for a sticky-write firmware
+  volume, a write may negate a bit in the EFI_FVB_ERASE_POLARITY
+  state but cannot flip it back again. In general, before
+  calling the Write() function, the caller should call the
+  EraseBlocks() function first to erase the specified block to
+  write. A block erase cycle will transition bits from the
+  (NOT)EFI_FVB_ERASE_POLARITY state back to the
+  EFI_FVB_ERASE_POLARITY state. Implementations should be
+  mindful that the firmware volume might be in the WriteDisabled
+  state. If it is in this state, the Write() function must
+  return the status code EFI_ACCESS_DENIED without modifying the
+  contents of the firmware volume. The Write() function must
+  also prevent spanning block boundaries. If a write is
+  requested that spans a block boundary, the write must store up
+  to the boundary but not beyond. The output parameter NumBytes
+  must be set to correctly indicate the number of bytes actually
+  written. The caller must be aware that a write may be
+  partially completed. All writes, partial or otherwise, must be
+  fully flushed to the hardware before the Write() service
+  returns.
+
+  @param This     Indicates the EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL instance.
+  
+  @param Lba      The starting logical block index to write to.
+  
+  @param Offset   Offset into the block at which to begin writing.
+  
+  @param NumBytes Pointer to a UINTN. At entry, *NumBytes
+                  contains the total size of the buffer. At
+                  exit, *NumBytes contains the total number of
+                  bytes actually written.
+  
+  @param Buffer   Pointer to a caller-allocated buffer that
+                  contains the source for the write.
+  
+  @retval EFI_SUCCESS         The firmware volume was written successfully.
+  
+  @retval EFI_BAD_BUFFER_SIZE The write was attempted across an
+                              LBA boundary. On output, NumBytes
+                              contains the total number of bytes
+                              actually written.
+  
+  @retval EFI_ACCESS_DENIED   The firmware volume is in the
+                              WriteDisabled state.
+  
+  @retval EFI_DEVICE_ERROR    The block device is malfunctioning
+                              and could not be written.
+
+
+**/
+EFI_STATUS
+EFIAPI
+FvbProtocolWrite (
+  IN CONST  EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL *This,
+  IN        EFI_LBA                             Lba,
+  IN        UINTN                               Offset,
+  IN OUT    UINTN                               *NumBytes,
+  IN        UINT8                               *Buffer
+  )
+{
+
+  EFI_FW_VOL_BLOCK_DEVICE *FvbDevice;
+  UINT8                   *FvbDataPtr;
+
+  DEBUG ((EFI_D_ERROR, "-----------------FvbProtocolWrite\n"));
+  FvbDevice = FVB_DEVICE_FROM_THIS (This);
+
+  if ((Lba > 1) || (Offset > FvbDevice->BlockSize)) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if ((Offset + *NumBytes) > FvbDevice->BlockSize) {
+    *NumBytes = FvbDevice->BlockSize - Offset;
+  }
+
+  FvbDataPtr =
+    (UINT8*) FvbDevice->BufferPtr +
+    MultU64x32 (Lba, (UINT32) FvbDevice->BlockSize) +
+    Offset;
+
+  if (*NumBytes > 0) {
+    CopyMem (FvbDataPtr, Buffer, *NumBytes);
+    PlatformFvbDataWritten (This, Lba, Offset, *NumBytes, Buffer);
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Reads the specified number of bytes into a buffer from the specified block.
+
+  The Read() function reads the requested number of bytes from the
+  requested block and stores them in the provided buffer.
+  Implementations should be mindful that the firmware volume
+  might be in the ReadDisabled state. If it is in this state,
+  the Read() function must return the status code
+  EFI_ACCESS_DENIED without modifying the contents of the
+  buffer. The Read() function must also prevent spanning block
+  boundaries. If a read is requested that would span a block
+  boundary, the read must read up to the boundary but not
+  beyond. The output parameter NumBytes must be set to correctly
+  indicate the number of bytes actually read. The caller must be
+  aware that a read may be partially completed.
+
+  @param This     Indicates the EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL instance.
+  
+  @param Lba      The starting logical block index
+                  from which to read.
+
+  @param Offset   Offset into the block at which to begin reading.
+
+  @param NumBytes Pointer to a UINTN. At entry, *NumBytes
+                  contains the total size of the buffer. At
+                  exit, *NumBytes contains the total number of
+                  bytes read.
+
+  @param Buffer   Pointer to a caller-allocated buffer that will
+                  be used to hold the data that is read.
+
+  @retval EFI_SUCCESS         The firmware volume was read successfully
+                              and contents are in Buffer.
+  
+  @retval EFI_BAD_BUFFER_SIZE Read attempted across an LBA
+                              boundary. On output, NumBytes
+                              contains the total number of bytes
+                              returned in Buffer.
+  
+  @retval EFI_ACCESS_DENIED   The firmware volume is in the
+                              ReadDisabled state.
+  
+  @retval EFI_DEVICE_ERROR    The block device is not
+                              functioning correctly and could
+                              not be read.
+
+**/
+EFI_STATUS
+EFIAPI
+FvbProtocolRead (
+  IN CONST  EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL *This,
+  IN        EFI_LBA                             Lba,
+  IN        UINTN                               Offset,
+  IN OUT    UINTN                               *NumBytes,
+  IN OUT    UINT8                               *Buffer
+  )
+{
+  EFI_FW_VOL_BLOCK_DEVICE *FvbDevice;
+  UINT8                   *FvbDataPtr;
+
+  DEBUG ((EFI_D_ERROR, "-----------------FvbProtocolRead\n"));
+  FvbDevice = FVB_DEVICE_FROM_THIS (This);
+
+  if ((Lba > 1) || (Offset > FvbDevice->BlockSize)) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if ((Offset + *NumBytes) > FvbDevice->BlockSize) {
+    *NumBytes = FvbDevice->BlockSize - Offset;
+  }
+
+  FvbDataPtr =
+    (UINT8*) FvbDevice->BufferPtr +
+    MultU64x32 (Lba, (UINT32) FvbDevice->BlockSize) +
+    Offset;
+
+  if (*NumBytes > 0) {
+    CopyMem (Buffer, FvbDataPtr, *NumBytes);
+    PlatformFvbDataRead (This, Lba, Offset, *NumBytes, Buffer);
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Check the integrity of firmware volume header.
+
+  @param[in] FwVolHeader - A pointer to a firmware volume header
+
+  @retval  EFI_SUCCESS   - The firmware volume is consistent
+  @retval  EFI_NOT_FOUND - The firmware volume has been corrupted.
+
+**/
+EFI_STATUS
+ValidateFvHeader (
+  IN EFI_FIRMWARE_VOLUME_HEADER   *FwVolHeader
+  )
+{
+  UINT16  Checksum;
+
+  //
+  // Verify the header revision, header signature, length
+  // Length of FvBlock cannot be 2**64-1
+  // HeaderLength cannot be an odd number
+  //
+  if ((FwVolHeader->Revision != EFI_FVH_REVISION) ||
+      (FwVolHeader->Signature != EFI_FVH_SIGNATURE) ||
+      (FwVolHeader->FvLength != EMU_FVB_SIZE) ||
+      (FwVolHeader->HeaderLength != EMU_FV_HEADER_LENGTH)
+      ) {
+    DEBUG ((EFI_D_INFO, "EMU Variable FVB: Basic FV headers were invalid\n"));
+    return EFI_NOT_FOUND;
+  }
+  //
+  // Verify the header checksum
+  //
+  Checksum = CalculateSum16((VOID*) FwVolHeader, FwVolHeader->HeaderLength);
+
+  if (Checksum != 0) {
+    DEBUG ((EFI_D_INFO, "EMU Variable FVB: FV checksum was invalid\n"));
+    return EFI_NOT_FOUND;
+  }
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Initializes the FV Header and Variable Store Header
+  to support variable operations.
+
+  @param[in]  Ptr - Location to initialize the headers
+
+**/
+VOID
+InitializeFvAndVariableStoreHeaders (
+  IN  VOID   *Ptr
+  )
+{
+  //
+  // Templates for standard (non-authenticated) variable FV header
+  //
+  STATIC FVB_FV_HDR_AND_VARS_TEMPLATE FvAndVarTemplate = {
+    { // EFI_FIRMWARE_VOLUME_HEADER FvHdr;
+      // UINT8                     ZeroVector[16];
+      { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+
+      // EFI_GUID                  FileSystemGuid;
+      EFI_SYSTEM_NV_DATA_FV_GUID,
+
+      // UINT64                    FvLength;
+      EMU_FVB_SIZE,
+
+      // UINT32                    Signature;
+      EFI_FVH_SIGNATURE,
+
+      // EFI_FVB_ATTRIBUTES_2      Attributes;
+      0x4feff,
+
+      // UINT16                    HeaderLength;
+      EMU_FV_HEADER_LENGTH,
+
+      // UINT16                    Checksum;
+      0,
+
+      // UINT16                    ExtHeaderOffset;
+      0,
+
+      // UINT8                     Reserved[1];
+      {0},
+
+      // UINT8                     Revision;
+      EFI_FVH_REVISION,
+
+      // EFI_FV_BLOCK_MAP_ENTRY    BlockMap[1];
+      { 
+        {
+          2, // UINT32 NumBlocks;
+          EMU_FVB_BLOCK_SIZE  // UINT32 Length;
+        }
+      }
+    },
+    // EFI_FV_BLOCK_MAP_ENTRY     EndBlockMap;
+    { 0, 0 }, // End of block map
+    { // VARIABLE_STORE_HEADER      VarHdr;
+      // EFI_GUID  Signature;
+      EFI_VARIABLE_GUID,
+
+      // UINT32  Size;
+      (
+        FixedPcdGet32 (PcdFlashNvStorageVariableSize) -
+        OFFSET_OF (FVB_FV_HDR_AND_VARS_TEMPLATE, VarHdr)
+      ),
+
+      // UINT8   Format;
+      VARIABLE_STORE_FORMATTED,
+
+      // UINT8   State;
+      VARIABLE_STORE_HEALTHY,
+
+      // UINT16  Reserved;
+      0,
+
+      // UINT32  Reserved1;
+      0
+    }
+  };
+
+  //
+  // Templates for authenticated variable FV header
+  //
+  STATIC FVB_FV_HDR_AND_VARS_TEMPLATE FvAndAuthenticatedVarTemplate = {
+    { // EFI_FIRMWARE_VOLUME_HEADER FvHdr;
+      // UINT8                     ZeroVector[16];
+      { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+
+      // EFI_GUID                  FileSystemGuid;
+      EFI_SYSTEM_NV_DATA_FV_GUID,
+
+      // UINT64                    FvLength;
+      EMU_FVB_SIZE,
+
+      // UINT32                    Signature;
+      EFI_FVH_SIGNATURE,
+
+      // EFI_FVB_ATTRIBUTES_2      Attributes;
+      0x4feff,
+
+      // UINT16                    HeaderLength;
+      EMU_FV_HEADER_LENGTH,
+
+      // UINT16                    Checksum;
+      0,
+
+      // UINT16                    ExtHeaderOffset;
+      0,
+
+      // UINT8                     Reserved[1];
+      {0},
+
+      // UINT8                     Revision;
+      EFI_FVH_REVISION,
+
+      // EFI_FV_BLOCK_MAP_ENTRY    BlockMap[1];
+      {
+        {
+          2, // UINT32 NumBlocks;
+          EMU_FVB_BLOCK_SIZE  // UINT32 Length;
+        }
+      }
+    },
+    // EFI_FV_BLOCK_MAP_ENTRY     EndBlockMap;
+    { 0, 0 }, // End of block map
+    { // VARIABLE_STORE_HEADER      VarHdr;
+        // EFI_GUID  Signature;     // need authenticated variables for secure boot
+        EFI_AUTHENTICATED_VARIABLE_GUID,
+
+      // UINT32  Size;
+      (
+        FixedPcdGet32 (PcdVariableStoreSize) -
+        OFFSET_OF (FVB_FV_HDR_AND_VARS_TEMPLATE, VarHdr)
+      ),
+
+      // UINT8   Format;
+      VARIABLE_STORE_FORMATTED,
+
+      // UINT8   State;
+      VARIABLE_STORE_HEALTHY,
+
+      // UINT16  Reserved;
+      0,
+
+      // UINT32  Reserved1;
+      0
+    }
+  };
+
+  EFI_FIRMWARE_VOLUME_HEADER  *Fv;
+
+  //
+  // Copy the template structure into the location
+  //
+  if (FeaturePcdGet (PcdSecureBootEnable) == FALSE) {
+    CopyMem (Ptr, (VOID*)&FvAndVarTemplate, sizeof (FvAndVarTemplate));
+  } else {
+    CopyMem (Ptr, (VOID*)&FvAndAuthenticatedVarTemplate, sizeof (FvAndAuthenticatedVarTemplate));
+  }
+
+  //
+  // Update the checksum for the FV header
+  //
+  Fv = (EFI_FIRMWARE_VOLUME_HEADER*) Ptr;
+  Fv->Checksum = CalculateCheckSum16 (Ptr, Fv->HeaderLength & 0xFFFE);
+}
+
+/**
+  Main entry point.
+
+  @param[in] ImageHandle    The firmware allocated handle for the EFI image.  
+  @param[in] SystemTable    A pointer to the EFI System Table.
+  
+  @retval EFI_SUCCESS       Successfully initialized.
+
+**/
+EFI_STATUS
+EFIAPI
+FvbInitialize (
+  IN EFI_HANDLE         ImageHandle,
+  IN EFI_SYSTEM_TABLE   *SystemTable
+  )
+{
+  EFI_STATUS                          Status;
+  VOID                                *Ptr;
+  VOID                                *SubPtr;
+  BOOLEAN                             Initialize;
+  EFI_HANDLE                          Handle;
+  EFI_PHYSICAL_ADDRESS                Address;
+
+  DEBUG ((EFI_D_INFO, "EMU Variable FVB Started\n"));
+
+  //
+  // Verify that the PCD's are set correctly.
+  //
+  if (
+       (PcdGet32 (PcdFlashNvStorageVariableSize) +
+        PcdGet32 (PcdFlashNvStorageFtwWorkingSize)
+       ) >
+       FixedPcdGet32 (PcdFlashNvStorageFtwSpareSize)
+     ) {
+    DEBUG ((EFI_D_ERROR, "EMU Variable invalid PCD sizes\n"));
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (PcdGet64 (PcdFlashNvStorageVariableBase64) != 0) {
+    DEBUG ((EFI_D_INFO, "Disabling EMU Variable FVB since "
+                        "flash variables appear to be supported.\n"));
+    return EFI_ABORTED;
+  }
+
+  //
+  // By default we will initialize the FV contents.  But, if
+  // PcdEmuVariableNvStoreReserved is non-zero, then we will
+  // use this location for our buffer.
+  //
+  // If this location does not have a proper FV header, then
+  // we will initialize it.
+  //
+  Initialize = TRUE;
+  if (PcdGet64 (PcdEmuVariableNvStoreReserved) != 0) {
+    Ptr = (VOID*)(UINTN) PcdGet64 (PcdEmuVariableNvStoreReserved);
+    DEBUG ((
+      EFI_D_INFO,
+      "EMU Variable FVB: Using pre-reserved block at %p\n",
+      Ptr
+      ));
+    Status = ValidateFvHeader (Ptr);
+    if (!EFI_ERROR (Status)) {
+      DEBUG ((EFI_D_INFO, "EMU Variable FVB: Found valid pre-existing FV\n"));
+      Initialize = FALSE;
+    }
+  } else {
+    Ptr = AllocateAlignedRuntimePages (
+            EFI_SIZE_TO_PAGES (EMU_FVB_SIZE),
+            SIZE_64KB
+            );
+  }
+
+  mEmuVarsFvb.BufferPtr = Ptr;
+
+  //
+  // Initialize the main FV header and variable store header
+  //
+  if (Initialize) {
+    SetMem (Ptr, EMU_FVB_SIZE, ERASED_UINT8);
+    InitializeFvAndVariableStoreHeaders (Ptr);
+  }
+  PcdSet64 (PcdFlashNvStorageVariableBase64, (UINTN) Ptr);
+
+
+
+  {
+  // declare the fake NVRAM range as 'runtime' so that virtual
+  // addressing will be available when an OS calls our code.
+  EFI_GCD_MEMORY_SPACE_DESCRIPTOR GcdDescriptor;
+  UINT64 nvPhysical = (UINTN) Ptr;
+  Status = gDS->GetMemorySpaceDescriptor (nvPhysical, &GcdDescriptor);
+  Status = gDS->SetMemorySpaceAttributes (
+                  nvPhysical,
+                  PcdGet32 (PcdFlashNvStorageFtwSpareSize) * 2,
+                  GcdDescriptor.Attributes | EFI_MEMORY_RUNTIME
+                  );
+  ASSERT_EFI_ERROR (Status);
+  }
+
+
+
+  //
+  // Initialize the Fault Tolerant Write data area
+  //
+  SubPtr = (VOID*) ((UINT8*) Ptr + PcdGet32 (PcdFlashNvStorageVariableSize));
+  PcdSet64 (PcdFlashNvStorageFtwWorkingBase64, (UINTN) SubPtr);
+
+  //
+  // Initialize the Fault Tolerant Write spare block
+  //
+  SubPtr = (VOID*) ((UINT8*) Ptr + EMU_FVB_BLOCK_SIZE);
+  PcdSet64 (PcdFlashNvStorageFtwSpareBase64, (UINTN) SubPtr);
+
+  //
+  // Setup FVB device path
+  //
+  Address = (EFI_PHYSICAL_ADDRESS)(UINTN) Ptr;
+  mEmuVarsFvb.DevicePath.MemMapDevPath.StartingAddress = Address;
+  mEmuVarsFvb.DevicePath.MemMapDevPath.EndingAddress = Address + EMU_FVB_SIZE - 1;
+
+  //
+  // Install the protocols
+  //
+  DEBUG ((EFI_D_INFO, "Installing FVB for EMU Variable support\n"));
+  Handle = 0;
+  Status = gBS->InstallMultipleProtocolInterfaces (
+                  &Handle,
+                  &gEfiFirmwareVolumeBlock2ProtocolGuid,
+                  &mEmuVarsFvb.FwVolBlockInstance,
+                  &gEfiDevicePathProtocolGuid,
+                  &mEmuVarsFvb.DevicePath,
+                  NULL
+                  );
+  ASSERT_EFI_ERROR (Status);
+
+  //
+  // Register for the virtual address change event
+  //
+  Status = gBS->CreateEventEx (
+                  EVT_NOTIFY_SIGNAL,
+                  TPL_NOTIFY,
+                  FvbVirtualAddressChangeEvent,
+                  NULL,
+                  &gEfiEventVirtualAddressChangeGuid,
+                  &mEmuVarsFvbAddrChangeEvent
+                  );
+  ASSERT_EFI_ERROR (Status);
+
+  return EFI_SUCCESS;
+}
+
+
Index: DuetPkg/EmuVariableFvbRuntimeDxe/Fvb.h
===================================================================
--- DuetPkg/EmuVariableFvbRuntimeDxe/Fvb.h	(revision 0)
+++ DuetPkg/EmuVariableFvbRuntimeDxe/Fvb.h	(working copy)
@@ -0,0 +1,140 @@
+/*++
+
+Copyright (c) 2006, Intel Corporation. All rights reserved.<BR>
+This program and the accompanying materials                          
+are licensed and made available under the terms and conditions of the BSD License         
+which accompanies this distribution.  The full text of the license may be found at        
+http://opensource.org/licenses/bsd-license.php                                            
+                                                                                          
+THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,                     
+WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.             
+
+Module Name:
+
+  FwBlockService.h
+  
+Abstract:
+
+  Firmware volume block driver for Intel Firmware Hub (FWH) device
+
+--*/
+
+#ifndef _FW_BLOCK_SERVICE_H
+#define _FW_BLOCK_SERVICE_H
+
+//
+// Fvb Protocol instance data
+//
+#define FVB_DEVICE_FROM_THIS(a)         CR (a, EFI_FW_VOL_BLOCK_DEVICE, FwVolBlockInstance, FVB_DEVICE_SIGNATURE)
+#define FVB_DEVICE_SIGNATURE            SIGNATURE_32 ('F', 'V', 'B', 'N')
+
+#pragma pack (1)
+
+typedef struct {
+
+  EFI_FIRMWARE_VOLUME_HEADER FvHdr;
+  EFI_FV_BLOCK_MAP_ENTRY     EndBlockMap;
+  VARIABLE_STORE_HEADER      VarHdr;
+
+} FVB_FV_HDR_AND_VARS_TEMPLATE;
+
+typedef struct {
+  MEMMAP_DEVICE_PATH        MemMapDevPath;
+  EFI_DEVICE_PATH_PROTOCOL  EndDevPath;
+} FV_DEVICE_PATH;
+
+#pragma pack ()
+
+typedef struct {
+  UINTN                               Signature;
+  FV_DEVICE_PATH                      DevicePath;
+  VOID                                *BufferPtr;
+  UINTN                               BlockSize;
+  UINTN                               Size;
+  EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL  FwVolBlockInstance;
+} EFI_FW_VOL_BLOCK_DEVICE;
+
+
+//
+// Constants
+//
+#define EMU_FVB_BLOCK_SIZE (FixedPcdGet32 (PcdFlashNvStorageFtwSpareSize))
+#define EMU_FVB_SIZE (2 * FixedPcdGet32 (PcdFlashNvStorageFtwSpareSize))
+#define FTW_WRITE_QUEUE_SIZE \
+  (FixedPcdGet32 (PcdFlashNvStorageFtwWorkingSize) - \
+   sizeof (EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER))
+#define EMU_FV_HEADER_LENGTH OFFSET_OF (FVB_FV_HDR_AND_VARS_TEMPLATE, VarHdr)
+
+#define NOT_ERASED_BIT 0
+#define ERASED_BIT     1
+#define ERASED_UINT8   0xff
+#define ERASED_UINT32  0xffffffff
+
+//
+// Protocol APIs
+//
+EFI_STATUS
+EFIAPI
+FvbProtocolGetAttributes (
+  IN CONST  EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL  *This,
+  OUT       EFI_FVB_ATTRIBUTES_2                *Attributes
+  )
+;
+
+EFI_STATUS
+EFIAPI
+FvbProtocolSetAttributes (
+  IN CONST  EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL  *This,
+  IN OUT    EFI_FVB_ATTRIBUTES_2                *Attributes
+  )
+;
+
+EFI_STATUS
+EFIAPI
+FvbProtocolGetPhysicalAddress (
+  IN CONST  EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL  *This,
+  OUT       EFI_PHYSICAL_ADDRESS                *Address
+  )
+;
+
+EFI_STATUS
+EFIAPI
+FvbProtocolGetBlockSize (
+  IN CONST  EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL  *This,
+  IN        EFI_LBA                             Lba,
+  OUT       UINTN                               *BlockSize,
+  OUT       UINTN                               *NumberOfBlocks
+  )
+;
+
+EFI_STATUS
+EFIAPI
+FvbProtocolRead (
+  IN CONST  EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL  *This,
+  IN        EFI_LBA                             Lba,
+  IN        UINTN                               Offset,
+  IN OUT    UINTN                               *NumBytes,
+  IN OUT    UINT8                               *Buffer
+  )
+;
+
+EFI_STATUS
+EFIAPI
+FvbProtocolWrite (
+  IN CONST  EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL  *This,
+  IN        EFI_LBA                             Lba,
+  IN        UINTN                               Offset,
+  IN OUT    UINTN                               *NumBytes,
+  IN        UINT8                               *Buffer
+  )
+;
+
+EFI_STATUS
+EFIAPI
+FvbProtocolEraseBlocks (
+  IN CONST  EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL  *This,
+  ...
+  )
+;
+
+#endif
Index: DuetPkg/EmuVariableFvbRuntimeDxe/Fvb.inf
===================================================================
--- DuetPkg/EmuVariableFvbRuntimeDxe/Fvb.inf	(revision 0)
+++ DuetPkg/EmuVariableFvbRuntimeDxe/Fvb.inf	(working copy)
@@ -0,0 +1,78 @@
+## @file
+#  Firmware Block Services to support emulating non-volatile variables
+#  by pretending that a memory buffer is storage for the NV variables.
+#
+#  Copyright (c) 2008 - 2011, Intel Corporation. All rights reserved.<BR>
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution. The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = EmuVariableFvbRuntimeDxe
+  FILE_GUID                      = 22dc2b60-fe40-42ac-b01f-3ab1fad9aad8
+  MODULE_TYPE                    = DXE_RUNTIME_DRIVER
+  VERSION_STRING                 = 1.0
+  ENTRY_POINT                    = FvbInitialize
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 IPF EBC
+#
+
+[Sources]
+  Fvb.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  MdeModulePkg/MdeModulePkg.dec
+  DuetPkg/DuetPkg.dec
+
+[LibraryClasses]
+  BaseLib
+  BaseMemoryLib
+  DebugLib
+  DxeServicesTableLib
+  HobLib
+  MemoryAllocationLib
+  PcdLib
+  PlatformFvbLib
+  UefiBootServicesTableLib
+  UefiDriverEntryPoint
+  UefiLib
+  UefiRuntimeLib
+
+[Guids]
+  gEfiEventVirtualAddressChangeGuid             # ALWAYS_CONSUMED  Create Event: EVENT_GROUP_GUID
+
+[Protocols]
+  gEfiFirmwareVolumeBlock2ProtocolGuid          # PROTOCOL ALWAYS_PRODUCED
+  gEfiDevicePathProtocolGuid                    # PROTOCOL ALWAYS_PRODUCED
+
+[FixedPcd]
+  gEfiMdeModulePkgTokenSpaceGuid.PcdVariableStoreSize
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwWorkingSize
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwSpareSize
+
+[Pcd]
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageVariableSize
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageVariableBase64
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwWorkingBase
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwWorkingBase64
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwSpareBase
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwSpareBase64
+  gEfiMdeModulePkgTokenSpaceGuid.PcdEmuVariableNvStoreReserved
+
+[FeaturePcd]
+  gUefiDuetPkgTokenSpaceGuid.PcdSecureBootEnable
+
+[Depex]
+  TRUE
+
Index: DuetPkg/FSVariable/FSVariable.c
===================================================================
--- DuetPkg/FSVariable/FSVariable.c	(revision 1)
+++ DuetPkg/FSVariable/FSVariable.c	(working copy)
@@ -1,1954 +0,0 @@
-/*++
-
-Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
-This program and the accompanying materials
-are licensed and made available under the terms and conditions of the BSD License
-which accompanies this distribution.  The full text of the license may be found at
-http://opensource.org/licenses/bsd-license.php
-
-THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-Module Name:
-
-  FSVariable.c
-
-Abstract:
-
-  Provide support functions for variable services.
-
---*/
-
-#include "FSVariable.h"
-
-VARIABLE_STORE_HEADER mStoreHeaderTemplate = {
-  VARIABLE_STORE_SIGNATURE,
-  VOLATILE_VARIABLE_STORE_SIZE,
-  VARIABLE_STORE_FORMATTED,
-  VARIABLE_STORE_HEALTHY,
-  0,
-  0
-};
-
-//
-// Don't use module globals after the SetVirtualAddress map is signaled
-//
-VARIABLE_GLOBAL  *mGlobal;
-
-/**
-  Update the variable region with Variable information. These are the same 
-  arguments as the EFI Variable services.
-
-  @param[in] VariableName       Name of variable
-
-  @param[in] VendorGuid         Guid of variable
-
-  @param[in] Data               Variable data
-
-  @param[in] DataSize           Size of data. 0 means delete
-
-  @param[in] Attributes         Attribues of the variable
-
-  @param[in] Variable           The variable information which is used to keep track of variable usage.
-
-  @retval EFI_SUCCESS           The update operation is success.
-
-  @retval EFI_OUT_OF_RESOURCES  Variable region is full, can not write other data into this region.
-
-**/
-EFI_STATUS
-EFIAPI
-UpdateVariable (
-  IN      CHAR16                 *VariableName,
-  IN      EFI_GUID               *VendorGuid,
-  IN      VOID                   *Data,
-  IN      UINTN                  DataSize,
-  IN      UINT32                 Attributes OPTIONAL,
-  IN      VARIABLE_POINTER_TRACK *Variable
-  );
-
-VOID
-EFIAPI
-OnVirtualAddressChangeFsv (
-  IN EFI_EVENT        Event,
-  IN VOID             *Context
-  );
-
-VOID
-EFIAPI
-OnSimpleFileSystemInstall (
-  IN EFI_EVENT        Event,
-  IN VOID             *Context
-  );
-
-BOOLEAN
-IsValidVariableHeader (
-  IN  VARIABLE_HEADER   *Variable
-  )
-/*++
-
-Routine Description:
-
-  This code checks if variable header is valid or not.
-
-Arguments:
-  Variable        Pointer to the Variable Header.
-
-Returns:
-  TRUE            Variable header is valid.
-  FALSE           Variable header is not valid.
-
---*/
-{
-  if (Variable == NULL || Variable->StartId != VARIABLE_DATA) {
-    return FALSE;
-  }
-
-  return TRUE;
-}
-
-VARIABLE_STORE_STATUS
-GetVariableStoreStatus (
-  IN VARIABLE_STORE_HEADER *VarStoreHeader
-  )
-/*++
-
-Routine Description:
-
-  This code gets the current status of Variable Store.
-
-Arguments:
-
-  VarStoreHeader  Pointer to the Variable Store Header.
-
-Returns:
-
-  EfiRaw        Variable store status is raw
-  EfiValid      Variable store status is valid
-  EfiInvalid    Variable store status is invalid
-
---*/
-{
-  if (CompareGuid (&VarStoreHeader->Signature, &mStoreHeaderTemplate.Signature) &&
-      (VarStoreHeader->Format == mStoreHeaderTemplate.Format) &&
-      (VarStoreHeader->State == mStoreHeaderTemplate.State)
-     ) {
-    return EfiValid;
-  } else if (((UINT32 *)(&VarStoreHeader->Signature))[0] == VAR_DEFAULT_VALUE_32 &&
-             ((UINT32 *)(&VarStoreHeader->Signature))[1] == VAR_DEFAULT_VALUE_32 &&
-             ((UINT32 *)(&VarStoreHeader->Signature))[2] == VAR_DEFAULT_VALUE_32 &&
-             ((UINT32 *)(&VarStoreHeader->Signature))[3] == VAR_DEFAULT_VALUE_32 &&
-             VarStoreHeader->Size == VAR_DEFAULT_VALUE_32 &&
-             VarStoreHeader->Format == VAR_DEFAULT_VALUE &&
-             VarStoreHeader->State == VAR_DEFAULT_VALUE
-          ) {
-
-    return EfiRaw;
-  } else {
-    return EfiInvalid;
-  }
-}
-
-UINT8 *
-GetVariableDataPtr (
-  IN  VARIABLE_HEADER   *Variable
-  )
-/*++
-
-Routine Description:
-
-  This code gets the pointer to the variable data.
-
-Arguments:
-
-  Variable            Pointer to the Variable Header.
-
-Returns:
-
-  UINT8*              Pointer to Variable Data
-
---*/
-{
-  //
-  // Be careful about pad size for alignment
-  //
-  return (UINT8 *) ((UINTN) GET_VARIABLE_NAME_PTR (Variable) + Variable->NameSize + GET_PAD_SIZE (Variable->NameSize));
-}
-
-VARIABLE_HEADER *
-GetNextVariablePtr (
-  IN  VARIABLE_HEADER   *Variable
-  )
-/*++
-
-Routine Description:
-
-  This code gets the pointer to the next variable header.
-
-Arguments:
-
-  Variable              Pointer to the Variable Header.
-
-Returns:
-
-  VARIABLE_HEADER*      Pointer to next variable header.
-
---*/
-{
-  if (!IsValidVariableHeader (Variable)) {
-    return NULL;
-  }
-  //
-  // Be careful about pad size for alignment
-  //
-  return (VARIABLE_HEADER *) ((UINTN) GetVariableDataPtr (Variable) + Variable->DataSize + GET_PAD_SIZE (Variable->DataSize));
-}
-
-VARIABLE_HEADER *
-GetEndPointer (
-  IN VARIABLE_STORE_HEADER       *VarStoreHeader
-  )
-/*++
-
-Routine Description:
-
-  This code gets the pointer to the last variable memory pointer byte
-
-Arguments:
-
-  VarStoreHeader        Pointer to the Variable Store Header.
-
-Returns:
-
-  VARIABLE_HEADER*      Pointer to last unavailable Variable Header
-
---*/
-{
-  //
-  // The end of variable store
-  //
-  return (VARIABLE_HEADER *) ((UINTN) VarStoreHeader + VarStoreHeader->Size);
-}
-
-BOOLEAN
-ExistNewerVariable (
-  IN  VARIABLE_HEADER         *Variable
-  )
-/*++
-
-Routine Description:
-
-  Check if exist newer variable when doing reclaim
-
-Arguments:
-
-  Variable                    Pointer to start position
-
-Returns:
-
-  TRUE - Exists another variable, which is newer than the current one
-  FALSE  - Doesn't exist another vairable which is newer than the current one
-
---*/
-{
-  VARIABLE_HEADER       *NextVariable;
-  CHAR16                *VariableName;
-  EFI_GUID              *VendorGuid;
-  
-  VendorGuid   = &Variable->VendorGuid;
-  VariableName = GET_VARIABLE_NAME_PTR(Variable);
-  
-  NextVariable = GetNextVariablePtr (Variable);
-  while (IsValidVariableHeader (NextVariable)) {
-    if ((NextVariable->State == VAR_ADDED) || (NextVariable->State == (VAR_ADDED & VAR_IN_DELETED_TRANSITION))) {
-      //
-      // If match Guid and Name
-      //
-      if (CompareGuid (VendorGuid, &NextVariable->VendorGuid)) {
-         if (CompareMem (VariableName, GET_VARIABLE_NAME_PTR (NextVariable), StrSize (VariableName)) == 0) {
-           return TRUE;
-         }
-       }
-    }
-    NextVariable = GetNextVariablePtr (NextVariable);
-  }
-  return FALSE;
-}
-
-EFI_STATUS
-Reclaim (
-  IN  VARIABLE_STORAGE_TYPE StorageType,
-  IN  VARIABLE_HEADER       *CurrentVariable OPTIONAL
-  )
-/*++
-
-Routine Description:
-
-  Variable store garbage collection and reclaim operation
-
-Arguments:
-
-  IsVolatile                  The variable store is volatile or not,
-                              if it is non-volatile, need FTW
-  CurrentVairable             If it is not NULL, it means not to process
-                              current variable for Reclaim.
-
-Returns:
-
-  EFI STATUS
-
---*/
-{
-  VARIABLE_HEADER       *Variable;
-  VARIABLE_HEADER       *NextVariable;
-  VARIABLE_STORE_HEADER *VariableStoreHeader;
-  UINT8                 *ValidBuffer;
-  UINTN                 ValidBufferSize;
-  UINTN                 VariableSize;
-  UINT8                 *CurrPtr;
-  EFI_STATUS            Status;
-
-  VariableStoreHeader = (VARIABLE_STORE_HEADER *) mGlobal->VariableBase[StorageType];
-
-  //
-  // Start Pointers for the variable.
-  //
-  Variable        = (VARIABLE_HEADER *) (VariableStoreHeader + 1);
-
-  //
-  // recaluate the total size of Common/HwErr type variables in non-volatile area.
-  //
-  if (!StorageType) {
-    mGlobal->CommonVariableTotalSize = 0;
-    mGlobal->HwErrVariableTotalSize  = 0;
-  }
-  //
-  // To make the reclaim, here we just allocate a memory that equal to the original memory
-  //
-  ValidBufferSize = sizeof (VARIABLE_STORE_HEADER) + VariableStoreHeader->Size;
-
-  Status = gBS->AllocatePool (
-                  EfiBootServicesData,
-                  ValidBufferSize,
-                  (VOID**) &ValidBuffer
-                  );
-  if (EFI_ERROR (Status)) {
-    return Status;
-  }
-
-  CurrPtr = ValidBuffer;
-
-  //
-  // Copy variable store header
-  //
-  CopyMem (CurrPtr, VariableStoreHeader, sizeof (VARIABLE_STORE_HEADER));
-  CurrPtr += sizeof (VARIABLE_STORE_HEADER);
-
-  //
-  // Start Pointers for the variable.
-  //
-  Variable = (VARIABLE_HEADER *) (VariableStoreHeader + 1);
-
-  
-  ValidBufferSize = sizeof (VARIABLE_STORE_HEADER);
-  while (IsValidVariableHeader (Variable)) {
-    NextVariable = GetNextVariablePtr (Variable);
-    //
-    // State VAR_ADDED or VAR_IN_DELETED_TRANSITION are to kept,
-    // The CurrentVariable, is also saved, as SetVariable may fail due to lack of space
-    //
-    if (Variable->State == VAR_ADDED) {
-      VariableSize = (UINTN) NextVariable - (UINTN) Variable;
-      CopyMem (CurrPtr, (UINT8 *) Variable, VariableSize);
-      ValidBufferSize += VariableSize;
-      CurrPtr += VariableSize;
-      if ((!StorageType) && ((Variable->Attributes & EFI_VARIABLE_HARDWARE_ERROR_RECORD) == EFI_VARIABLE_HARDWARE_ERROR_RECORD)) {
-        mGlobal->HwErrVariableTotalSize += VariableSize;
-      } else if ((!StorageType) && ((Variable->Attributes & EFI_VARIABLE_HARDWARE_ERROR_RECORD) != EFI_VARIABLE_HARDWARE_ERROR_RECORD)) {
-        mGlobal->CommonVariableTotalSize += VariableSize;
-      }
-    } else if (Variable->State == (VAR_ADDED & VAR_IN_DELETED_TRANSITION)) {
-      //
-      // As variables that with the same guid and name may exist in NV due to power failure during SetVariable,
-      // we will only save the latest valid one
-      //
-      if (!ExistNewerVariable(Variable)) {
-        VariableSize = (UINTN) NextVariable - (UINTN) Variable;
-        CopyMem (CurrPtr, (UINT8 *) Variable, VariableSize);
-        //
-        // If CurrentVariable == Variable, mark as VAR_IN_DELETED_TRANSITION
-        //
-        if (Variable != CurrentVariable){
-          ((VARIABLE_HEADER *)CurrPtr)->State = VAR_ADDED;
-        }
-        CurrPtr += VariableSize;
-        ValidBufferSize += VariableSize;
-        if ((!StorageType) && ((Variable->Attributes & EFI_VARIABLE_HARDWARE_ERROR_RECORD) == EFI_VARIABLE_HARDWARE_ERROR_RECORD)) {
-          mGlobal->HwErrVariableTotalSize += VariableSize;
-        } else if ((!StorageType) && ((Variable->Attributes & EFI_VARIABLE_HARDWARE_ERROR_RECORD) != EFI_VARIABLE_HARDWARE_ERROR_RECORD)) {
-          mGlobal->CommonVariableTotalSize += VariableSize;
-        }
-      }
-    }
-    Variable = NextVariable;
-  }
-
-  mGlobal->LastVariableOffset[StorageType] = ValidBufferSize;
-
-  //
-  // TODO: cannot restore to original state, basic FTW needed
-  //
-  Status = mGlobal->VariableStore[StorageType]->Erase (
-                                                  mGlobal->VariableStore[StorageType]
-                                                  );
-  Status = mGlobal->VariableStore[StorageType]->Write (
-                                                    mGlobal->VariableStore[StorageType],
-                                                    0,
-                                                    ValidBufferSize,
-                                                    ValidBuffer
-                                                    );
-
-  if (EFI_ERROR (Status)) {
-    //
-    // If error, then reset the last variable offset to zero.
-    //
-    mGlobal->LastVariableOffset[StorageType] = 0;
-  };
-
-  gBS->FreePool (ValidBuffer);
-
-  return Status;
-}
-
-EFI_STATUS
-FindVariable (
-  IN  CHAR16                  *VariableName,
-  IN  EFI_GUID                *VendorGuid,
-  OUT VARIABLE_POINTER_TRACK  *PtrTrack
-  )
-/*++
-
-Routine Description:
-
-  This code finds variable in storage blocks (Volatile or Non-Volatile)
-
-Arguments:
-
-  VariableName                Name of the variable to be found
-  VendorGuid                  Vendor GUID to be found.
-  PtrTrack                    Variable Track Pointer structure that contains
-                              Variable Information.
-                              Contains the pointer of Variable header.
-
-Returns:
-
-  EFI_INVALID_PARAMETER       - Invalid parameter
-  EFI_SUCCESS                 - Find the specified variable
-  EFI_NOT_FOUND               - Not found
-
---*/
-{
-  VARIABLE_HEADER         *Variable;
-  VARIABLE_STORE_HEADER   *VariableStoreHeader;
-  UINTN                   Index;
-  VARIABLE_HEADER         *InDeleteVariable;
-  UINTN                   InDeleteIndex;
-  VARIABLE_HEADER         *InDeleteStartPtr;
-  VARIABLE_HEADER         *InDeleteEndPtr;
-
-  if (VariableName[0] != 0 && VendorGuid == NULL) {
-    return EFI_INVALID_PARAMETER;
-  }
-
-  InDeleteVariable = NULL;
-  InDeleteIndex    = (UINTN)-1;
-  InDeleteStartPtr = NULL;
-  InDeleteEndPtr   = NULL;
-
-  for (Index = 0; Index < MaxType; Index ++) {
-    //
-    // 0: Non-Volatile, 1: Volatile
-    //
-    VariableStoreHeader = (VARIABLE_STORE_HEADER *) mGlobal->VariableBase[Index];
-
-    //
-    // Start Pointers for the variable.
-    // Actual Data Pointer where data can be written.
-    //
-    Variable = (VARIABLE_HEADER *) (VariableStoreHeader + 1);
-
-    //
-    // Find the variable by walk through non-volatile and volatile variable store
-    //
-    PtrTrack->StartPtr = Variable;
-    PtrTrack->EndPtr   = GetEndPointer (VariableStoreHeader);
-
-    while ((Variable < PtrTrack->EndPtr) && IsValidVariableHeader (Variable)) {
-      if (Variable->State == VAR_ADDED) {
-        if (!EfiAtRuntime () || (Variable->Attributes & EFI_VARIABLE_RUNTIME_ACCESS)) {
-          if (VariableName[0] == 0) {
-            PtrTrack->CurrPtr = Variable;
-            PtrTrack->Type    = (VARIABLE_STORAGE_TYPE) Index;
-            return EFI_SUCCESS;
-          } else {
-            if (CompareGuid (VendorGuid, &Variable->VendorGuid)) {
-              if (!CompareMem (VariableName, GET_VARIABLE_NAME_PTR (Variable), StrSize (VariableName))) {
-                PtrTrack->CurrPtr = Variable;
-                PtrTrack->Type    = (VARIABLE_STORAGE_TYPE) Index;
-                return EFI_SUCCESS;
-              }
-            }
-          }
-        }
-      } else if (Variable->State == (VAR_ADDED & VAR_IN_DELETED_TRANSITION)) {
-        //
-        // VAR_IN_DELETED_TRANSITION should also be checked.
-        //
-        if (!EfiAtRuntime () || (Variable->Attributes & EFI_VARIABLE_RUNTIME_ACCESS)) {
-          if (VariableName[0] == 0) {
-            InDeleteVariable = Variable;
-            InDeleteIndex    = Index;
-            InDeleteStartPtr = PtrTrack->StartPtr;
-            InDeleteEndPtr   = PtrTrack->EndPtr;
-          } else {
-            if (CompareGuid (VendorGuid, &Variable->VendorGuid)) {
-              if (!CompareMem (VariableName, GET_VARIABLE_NAME_PTR (Variable), StrSize (VariableName))) {
-                InDeleteVariable = Variable;
-                InDeleteIndex    = Index;
-                InDeleteStartPtr = PtrTrack->StartPtr;
-                InDeleteEndPtr   = PtrTrack->EndPtr;
-              }
-            }
-          }
-        }
-      }
-
-      Variable = GetNextVariablePtr (Variable);
-    }
-    //
-    // While (...)
-    //
-  }
-  //
-  // for (...)
-  //
-
-  //
-  // if VAR_IN_DELETED_TRANSITION found, and VAR_ADDED not found,
-  // we return it.
-  //
-  if (InDeleteVariable != NULL) {
-    PtrTrack->CurrPtr  = InDeleteVariable;
-    PtrTrack->Type     = (VARIABLE_STORAGE_TYPE) InDeleteIndex;
-    PtrTrack->StartPtr = InDeleteStartPtr;
-    PtrTrack->EndPtr   = InDeleteEndPtr;
-    return EFI_SUCCESS;
-  }
-
-  PtrTrack->CurrPtr = NULL;
-  return EFI_NOT_FOUND;
-}
-
-/**
-  Get index from supported language codes according to language string.
-
-  This code is used to get corresponding index in supported language codes. It can handle
-  RFC4646 and ISO639 language tags.
-  In ISO639 language tags, take 3-characters as a delimitation to find matched string and calculate the index.
-  In RFC4646 language tags, take semicolon as a delimitation to find matched string and calculate the index.
-
-  For example:
-    SupportedLang  = "engfraengfra"
-    Lang           = "eng"
-    Iso639Language = TRUE
-  The return value is "0".
-  Another example:
-    SupportedLang  = "en;fr;en-US;fr-FR"
-    Lang           = "fr-FR"
-    Iso639Language = FALSE
-  The return value is "3".
-
-  @param  SupportedLang               Platform supported language codes.
-  @param  Lang                        Configured language.
-  @param  Iso639Language              A bool value to signify if the handler is operated on ISO639 or RFC4646.
-
-  @retval the index of language in the language codes.
-
-**/
-UINTN
-GetIndexFromSupportedLangCodes(
-  IN  CHAR8            *SupportedLang,
-  IN  CHAR8            *Lang,
-  IN  BOOLEAN          Iso639Language
-  ) 
-{
-  UINTN    Index;
-  UINTN    CompareLength;
-  UINTN    LanguageLength;
-
-  if (Iso639Language) {
-    CompareLength = ISO_639_2_ENTRY_SIZE;
-    for (Index = 0; Index < AsciiStrLen (SupportedLang); Index += CompareLength) {
-      if (AsciiStrnCmp (Lang, SupportedLang + Index, CompareLength) == 0) {
-        //
-        // Successfully find the index of Lang string in SupportedLang string.
-        //
-        Index = Index / CompareLength;
-        return Index;
-      }
-    }
-    ASSERT (FALSE);
-    return 0;
-  } else {
-    //
-    // Compare RFC4646 language code
-    //
-    Index = 0;
-    for (LanguageLength = 0; Lang[LanguageLength] != '\0'; LanguageLength++);
-
-    for (Index = 0; *SupportedLang != '\0'; Index++, SupportedLang += CompareLength) {
-      //
-      // Skip ';' characters in SupportedLang
-      //
-      for (; *SupportedLang != '\0' && *SupportedLang == ';'; SupportedLang++);
-      //
-      // Determine the length of the next language code in SupportedLang
-      //
-      for (CompareLength = 0; SupportedLang[CompareLength] != '\0' && SupportedLang[CompareLength] != ';'; CompareLength++);
-      
-      if ((CompareLength == LanguageLength) && 
-          (AsciiStrnCmp (Lang, SupportedLang, CompareLength) == 0)) {
-        //
-        // Successfully find the index of Lang string in SupportedLang string.
-        //
-        return Index;
-      }
-    }
-    ASSERT (FALSE);
-    return 0;
-  }
-}
-
-/**
-  Get language string from supported language codes according to index.
-
-  This code is used to get corresponding language string in supported language codes. It can handle
-  RFC4646 and ISO639 language tags.
-  In ISO639 language tags, take 3-characters as a delimitation. Find language string according to the index.
-  In RFC4646 language tags, take semicolon as a delimitation. Find language string according to the index.
-
-  For example:
-    SupportedLang  = "engfraengfra"
-    Index          = "1"
-    Iso639Language = TRUE
-  The return value is "fra".
-  Another example:
-    SupportedLang  = "en;fr;en-US;fr-FR"
-    Index          = "1"
-    Iso639Language = FALSE
-  The return value is "fr".
-
-  @param  SupportedLang               Platform supported language codes.
-  @param  Index                       the index in supported language codes.
-  @param  Iso639Language              A bool value to signify if the handler is operated on ISO639 or RFC4646.
-
-  @retval the language string in the language codes.
-
-**/
-CHAR8 *
-GetLangFromSupportedLangCodes (
-  IN  CHAR8            *SupportedLang,
-  IN  UINTN            Index,
-  IN  BOOLEAN          Iso639Language
-)
-{
-  UINTN    SubIndex;
-  UINTN    CompareLength;
-  CHAR8    *Supported;
-
-  SubIndex  = 0;
-  Supported = SupportedLang;
-  if (Iso639Language) {
-    //
-    // according to the index of Lang string in SupportedLang string to get the language.
-    // As this code will be invoked in RUNTIME, therefore there is not memory allocate/free operation.
-    // In driver entry, it pre-allocates a runtime attribute memory to accommodate this string.
-    //
-    CompareLength = ISO_639_2_ENTRY_SIZE;
-    mGlobal->Lang[CompareLength] = '\0';
-    return CopyMem (mGlobal->Lang, SupportedLang + Index * CompareLength, CompareLength);
-
-  } else {
-    while (TRUE) {
-      //
-      // take semicolon as delimitation, sequentially traverse supported language codes.
-      //
-      for (CompareLength = 0; *Supported != ';' && *Supported != '\0'; CompareLength++) {
-        Supported++;
-      }
-      if ((*Supported == '\0') && (SubIndex != Index)) {
-        //
-        // Have completed the traverse, but not find corrsponding string.
-        // This case is not allowed to happen.
-        //
-        ASSERT(FALSE);
-        return NULL;
-      }
-      if (SubIndex == Index) {
-        //
-        // according to the index of Lang string in SupportedLang string to get the language.
-        // As this code will be invoked in RUNTIME, therefore there is not memory allocate/free operation.
-        // In driver entry, it pre-allocates a runtime attribute memory to accommodate this string.
-        //
-        mGlobal->PlatformLang[CompareLength] = '\0';
-        return CopyMem (mGlobal->PlatformLang, Supported - CompareLength, CompareLength);
-      }
-      SubIndex++;
-
-      //
-      // Skip ';' characters in Supported
-      //
-      for (; *Supported != '\0' && *Supported == ';'; Supported++);
-    }
-  }
-}
-
-/**
-  Returns a pointer to an allocated buffer that contains the best matching language 
-  from a set of supported languages.  
-  
-  This function supports both ISO 639-2 and RFC 4646 language codes, but language 
-  code types may not be mixed in a single call to this function. This function
-  supports a variable argument list that allows the caller to pass in a prioritized
-  list of language codes to test against all the language codes in SupportedLanguages.
-
-  If SupportedLanguages is NULL, then ASSERT().
-
-  @param[in]  SupportedLanguages  A pointer to a Null-terminated ASCII string that
-                                  contains a set of language codes in the format 
-                                  specified by Iso639Language.
-  @param[in]  Iso639Language      If TRUE, then all language codes are assumed to be
-                                  in ISO 639-2 format.  If FALSE, then all language
-                                  codes are assumed to be in RFC 4646 language format
-  @param[in]  ...                 A variable argument list that contains pointers to 
-                                  Null-terminated ASCII strings that contain one or more
-                                  language codes in the format specified by Iso639Language.
-                                  The first language code from each of these language
-                                  code lists is used to determine if it is an exact or
-                                  close match to any of the language codes in 
-                                  SupportedLanguages.  Close matches only apply to RFC 4646
-                                  language codes, and the matching algorithm from RFC 4647
-                                  is used to determine if a close match is present.  If 
-                                  an exact or close match is found, then the matching
-                                  language code from SupportedLanguages is returned.  If
-                                  no matches are found, then the next variable argument
-                                  parameter is evaluated.  The variable argument list 
-                                  is terminated by a NULL.
-
-  @retval NULL   The best matching language could not be found in SupportedLanguages.
-  @retval NULL   There are not enough resources available to return the best matching 
-                 language.
-  @retval Other  A pointer to a Null-terminated ASCII string that is the best matching 
-                 language in SupportedLanguages.
-
-**/
-CHAR8 *
-EFIAPI
-VariableGetBestLanguage (
-  IN CONST CHAR8  *SupportedLanguages, 
-  IN BOOLEAN      Iso639Language,
-  ...
-  )
-{
-  VA_LIST      Args;
-  CHAR8        *Language;
-  UINTN        CompareLength;
-  UINTN        LanguageLength;
-  CONST CHAR8  *Supported;
-  CHAR8        *Buffer;
-
-  ASSERT (SupportedLanguages != NULL);
-
-  VA_START (Args, Iso639Language);
-  while ((Language = VA_ARG (Args, CHAR8 *)) != NULL) {
-    //
-    // Default to ISO 639-2 mode
-    //
-    CompareLength  = 3;
-    LanguageLength = MIN (3, AsciiStrLen (Language));
-
-    //
-    // If in RFC 4646 mode, then determine the length of the first RFC 4646 language code in Language
-    //
-    if (!Iso639Language) {
-      for (LanguageLength = 0; Language[LanguageLength] != 0 && Language[LanguageLength] != ';'; LanguageLength++);
-    }
-
-    //
-    // Trim back the length of Language used until it is empty
-    //
-    while (LanguageLength > 0) {
-      //
-      // Loop through all language codes in SupportedLanguages
-      //
-      for (Supported = SupportedLanguages; *Supported != '\0'; Supported += CompareLength) {
-        //
-        // In RFC 4646 mode, then Loop through all language codes in SupportedLanguages
-        //
-        if (!Iso639Language) {
-          //
-          // Skip ';' characters in Supported
-          //
-          for (; *Supported != '\0' && *Supported == ';'; Supported++);
-          //
-          // Determine the length of the next language code in Supported
-          //
-          for (CompareLength = 0; Supported[CompareLength] != 0 && Supported[CompareLength] != ';'; CompareLength++);
-          //
-          // If Language is longer than the Supported, then skip to the next language
-          //
-          if (LanguageLength > CompareLength) {
-            continue;
-          }
-        }
-        //
-        // See if the first LanguageLength characters in Supported match Language
-        //
-        if (AsciiStrnCmp (Supported, Language, LanguageLength) == 0) {
-          VA_END (Args);
-
-          Buffer = Iso639Language ? mGlobal->Lang : mGlobal->PlatformLang;
-          Buffer[CompareLength] = '\0';
-          return CopyMem (Buffer, Supported, CompareLength);
-        }
-      }
-
-      if (Iso639Language) {
-        //
-        // If ISO 639 mode, then each language can only be tested once
-        //
-        LanguageLength = 0;
-      } else {
-        //
-        // If RFC 4646 mode, then trim Language from the right to the next '-' character 
-        //
-        for (LanguageLength--; LanguageLength > 0 && Language[LanguageLength] != '-'; LanguageLength--);
-      }
-    }
-  }
-  VA_END (Args);
-
-  //
-  // No matches were found 
-  //
-  return NULL;
-}
-
-/**
-  Hook the operations in PlatformLangCodes, LangCodes, PlatformLang and Lang.
-
-  When setting Lang/LangCodes, simultaneously update PlatformLang/PlatformLangCodes.
-
-  According to UEFI spec, PlatformLangCodes/LangCodes are only set once in firmware initialization,
-  and are read-only. Therefore, in variable driver, only store the original value for other use.
-
-  @param[in] VariableName       Name of variable
-
-  @param[in] Data               Variable data
-
-  @param[in] DataSize           Size of data. 0 means delete
-
-**/
-VOID
-AutoUpdateLangVariable(
-  IN  CHAR16             *VariableName,
-  IN  VOID               *Data,
-  IN  UINTN              DataSize
-  )
-{
-  EFI_STATUS             Status;
-  CHAR8                  *BestPlatformLang;
-  CHAR8                  *BestLang;
-  UINTN                  Index;
-  UINT32                 Attributes;
-  VARIABLE_POINTER_TRACK Variable;
-  BOOLEAN                SetLanguageCodes;
-
-  //
-  // Don't do updates for delete operation
-  //
-  if (DataSize == 0) {
-    return;
-  }
-
-  SetLanguageCodes = FALSE;
-
-  if (StrCmp (VariableName, L"PlatformLangCodes") == 0) {
-    //
-    // PlatformLangCodes is a volatile variable, so it can not be updated at runtime.
-    //
-    if (EfiAtRuntime ()) {
-      return;
-    }
-
-    SetLanguageCodes = TRUE;
-
-    //
-    // According to UEFI spec, PlatformLangCodes is only set once in firmware initialization, and is read-only
-    // Therefore, in variable driver, only store the original value for other use.
-    //
-    if (mGlobal->PlatformLangCodes != NULL) {
-      FreePool (mGlobal->PlatformLangCodes);
-    }
-    mGlobal->PlatformLangCodes = AllocateRuntimeCopyPool (DataSize, Data);
-    ASSERT (mGlobal->PlatformLangCodes != NULL);
-
-    //
-    // PlatformLang holds a single language from PlatformLangCodes, 
-    // so the size of PlatformLangCodes is enough for the PlatformLang.
-    //
-    if (mGlobal->PlatformLang != NULL) {
-      FreePool (mGlobal->PlatformLang);
-    }
-    mGlobal->PlatformLang = AllocateRuntimePool (DataSize);
-    ASSERT (mGlobal->PlatformLang != NULL);
-
-  } else if (StrCmp (VariableName, L"LangCodes") == 0) {
-    //
-    // LangCodes is a volatile variable, so it can not be updated at runtime.
-    //
-    if (EfiAtRuntime ()) {
-      return;
-    }
-
-    SetLanguageCodes = TRUE;
-
-    //
-    // According to UEFI spec, LangCodes is only set once in firmware initialization, and is read-only
-    // Therefore, in variable driver, only store the original value for other use.
-    //
-    if (mGlobal->LangCodes != NULL) {
-      FreePool (mGlobal->LangCodes);
-    }
-    mGlobal->LangCodes = AllocateRuntimeCopyPool (DataSize, Data);
-    ASSERT (mGlobal->LangCodes != NULL);
-  }
-
-  if (SetLanguageCodes 
-      && (mGlobal->PlatformLangCodes != NULL)
-      && (mGlobal->LangCodes != NULL)) {
-    //
-    // Update Lang if PlatformLang is already set
-    // Update PlatformLang if Lang is already set
-    //
-    Status = FindVariable (L"PlatformLang", &gEfiGlobalVariableGuid, &Variable);
-    if (!EFI_ERROR (Status)) {
-      //
-      // Update Lang
-      //
-      VariableName = L"PlatformLang";
-      Data         = GetVariableDataPtr (Variable.CurrPtr);
-      DataSize     = Variable.CurrPtr->DataSize;
-    } else {
-      Status = FindVariable (L"Lang", &gEfiGlobalVariableGuid, &Variable);
-      if (!EFI_ERROR (Status)) {
-        //
-        // Update PlatformLang
-        //
-        VariableName = L"Lang";
-        Data         = GetVariableDataPtr (Variable.CurrPtr);
-        DataSize     = Variable.CurrPtr->DataSize;
-      } else {
-        //
-        // Neither PlatformLang nor Lang is set, directly return
-        //
-        return;
-      }
-    }
-  }
-  
-  //
-  // According to UEFI spec, "Lang" and "PlatformLang" is NV|BS|RT attributions.
-  //
-  Attributes = EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS;
-
-  if (StrCmp (VariableName, L"PlatformLang") == 0) {
-    //
-    // Update Lang when PlatformLangCodes/LangCodes were set.
-    //
-    if ((mGlobal->PlatformLangCodes != NULL) && (mGlobal->LangCodes != NULL)) {
-      //
-      // When setting PlatformLang, firstly get most matched language string from supported language codes.
-      //
-      BestPlatformLang = VariableGetBestLanguage (mGlobal->PlatformLangCodes, FALSE, Data, NULL);
-      if (BestPlatformLang != NULL) {
-        //
-        // Get the corresponding index in language codes.
-        //
-        Index = GetIndexFromSupportedLangCodes (mGlobal->PlatformLangCodes, BestPlatformLang, FALSE);
-
-        //
-        // Get the corresponding ISO639 language tag according to RFC4646 language tag.
-        //
-        BestLang = GetLangFromSupportedLangCodes (mGlobal->LangCodes, Index, TRUE);
-
-        //
-        // Successfully convert PlatformLang to Lang, and set the BestLang value into Lang variable simultaneously.
-        //
-        FindVariable(L"Lang", &gEfiGlobalVariableGuid, &Variable);
-
-        Status = UpdateVariable (L"Lang", &gEfiGlobalVariableGuid, BestLang, ISO_639_2_ENTRY_SIZE + 1, Attributes, &Variable);
-
-        DEBUG ((EFI_D_INFO, "Variable Driver Auto Update PlatformLang, PlatformLang:%a, Lang:%a\n", BestPlatformLang, BestLang));
-
-        ASSERT_EFI_ERROR(Status);
-      }
-    }
-
-  } else if (StrCmp (VariableName, L"Lang") == 0) {
-    //
-    // Update PlatformLang when PlatformLangCodes/LangCodes were set.
-    //
-    if ((mGlobal->PlatformLangCodes != NULL) && (mGlobal->LangCodes != NULL)) {
-      //
-      // When setting Lang, firstly get most matched language string from supported language codes.
-      //
-      BestLang = VariableGetBestLanguage (mGlobal->LangCodes, TRUE, Data, NULL);
-      if (BestLang != NULL) {
-        //
-        // Get the corresponding index in language codes.
-        //
-        Index = GetIndexFromSupportedLangCodes (mGlobal->LangCodes, BestLang, TRUE);
-
-        //
-        // Get the corresponding RFC4646 language tag according to ISO639 language tag.
-        //
-        BestPlatformLang = GetLangFromSupportedLangCodes (mGlobal->PlatformLangCodes, Index, FALSE);
-
-        //
-        // Successfully convert Lang to PlatformLang, and set the BestPlatformLang value into PlatformLang variable simultaneously.
-        //
-        FindVariable(L"PlatformLang", &gEfiGlobalVariableGuid, &Variable);
-
-        Status = UpdateVariable (L"PlatformLang", &gEfiGlobalVariableGuid, BestPlatformLang, 
-                                 AsciiStrSize (BestPlatformLang), Attributes, &Variable);
-
-        DEBUG ((EFI_D_INFO, "Variable Driver Auto Update Lang, Lang:%a, PlatformLang:%a\n", BestLang, BestPlatformLang));
-        ASSERT_EFI_ERROR (Status);
-      }
-    }
-  }
-}
-
-/**
-  Update the variable region with Variable information. These are the same 
-  arguments as the EFI Variable services.
-
-  @param[in] VariableName       Name of variable
-
-  @param[in] VendorGuid         Guid of variable
-
-  @param[in] Data               Variable data
-
-  @param[in] DataSize           Size of data. 0 means delete
-
-  @param[in] Attributes         Attribues of the variable
-
-  @param[in] Variable           The variable information which is used to keep track of variable usage.
-
-  @retval EFI_SUCCESS           The update operation is success.
-
-  @retval EFI_OUT_OF_RESOURCES  Variable region is full, can not write other data into this region.
-
-**/
-EFI_STATUS
-EFIAPI
-UpdateVariable (
-  IN      CHAR16                 *VariableName,
-  IN      EFI_GUID               *VendorGuid,
-  IN      VOID                   *Data,
-  IN      UINTN                  DataSize,
-  IN      UINT32                 Attributes OPTIONAL,
-  IN      VARIABLE_POINTER_TRACK *Variable
-  )
-{
-  EFI_STATUS                          Status;
-  VARIABLE_HEADER                     *NextVariable;
-  UINTN                               VarNameOffset;
-  UINTN                               VarDataOffset;
-  UINTN                               VarNameSize;
-  UINTN                               VarSize;
-  UINT8                               State;
-  BOOLEAN                             Reclaimed;
-  VARIABLE_STORAGE_TYPE               StorageType;
-
-  Reclaimed         = FALSE;
-
-  if (Variable->CurrPtr != NULL) {  
-    //
-    // Update/Delete existing variable
-    //
-    
-    if (EfiAtRuntime ()) {              
-      //
-      // If EfiAtRuntime and the variable is Volatile and Runtime Access,  
-      // the volatile is ReadOnly, and SetVariable should be aborted and 
-      // return EFI_WRITE_PROTECTED.
-      //
-      if (Variable->Type == Volatile) {
-        return EFI_WRITE_PROTECTED;
-      }
-      //
-      // Only variable have NV attribute can be updated/deleted in Runtime
-      //
-      if (!(Variable->CurrPtr->Attributes & EFI_VARIABLE_NON_VOLATILE)) {
-        return EFI_INVALID_PARAMETER;      
-      }
-    }
-    
-    //
-    // Setting a data variable with no access, or zero DataSize attributes
-    // specified causes it to be deleted.
-    //
-    if (DataSize == 0 || (Attributes & (EFI_VARIABLE_RUNTIME_ACCESS | EFI_VARIABLE_BOOTSERVICE_ACCESS)) == 0) {
-      //
-      // Found this variable in storage
-      //
-      State = Variable->CurrPtr->State;
-      State &= VAR_DELETED;
-
-      Status = mGlobal->VariableStore[Variable->Type]->Write (
-                                                        mGlobal->VariableStore[Variable->Type],
-                                                        VARIABLE_MEMBER_OFFSET (State, (UINTN) Variable->CurrPtr - (UINTN) Variable->StartPtr),
-                                                        sizeof (Variable->CurrPtr->State),
-                                                        &State
-                                                        );
-      //
-      // NOTE: Write operation at least can write data to memory cache
-      //       Discard file writing failure here.
-      //
-      return EFI_SUCCESS;
-    }
-    
-    //
-    // Found this variable in storage
-    // If the variable is marked valid and the same data has been passed in
-    // then return to the caller immediately.
-    //
-    if ((Variable->CurrPtr->DataSize == DataSize) &&
-        (CompareMem (Data, GetVariableDataPtr (Variable->CurrPtr), DataSize) == 0)
-          ) {
-      return EFI_SUCCESS;
-    } else if ((Variable->CurrPtr->State == VAR_ADDED) ||
-               (Variable->CurrPtr->State == (VAR_ADDED & VAR_IN_DELETED_TRANSITION))) {
-      //
-      // Mark the old variable as in delete transition
-      //
-      State = Variable->CurrPtr->State;
-      State &= VAR_IN_DELETED_TRANSITION;
-
-      Status = mGlobal->VariableStore[Variable->Type]->Write (
-                                                        mGlobal->VariableStore[Variable->Type],
-                                                        VARIABLE_MEMBER_OFFSET (State, (UINTN) Variable->CurrPtr - (UINTN) Variable->StartPtr),
-                                                        sizeof (Variable->CurrPtr->State),
-                                                        &State
-                                                        );
-      //
-      // NOTE: Write operation at least can write data to memory cache
-      //       Discard file writing failure here.
-      //
-    }
-  } else {
-    //
-    // Create a new variable
-    //  
-    
-    //
-    // Make sure we are trying to create a new variable.
-    // Setting a data variable with no access, or zero DataSize attributes means to delete it.    
-    //
-    if (DataSize == 0 || (Attributes & (EFI_VARIABLE_RUNTIME_ACCESS | EFI_VARIABLE_BOOTSERVICE_ACCESS)) == 0) {
-      return EFI_NOT_FOUND;
-    }    
-    //
-    // Only variable have NV|RT attribute can be created in Runtime
-    //
-    if (EfiAtRuntime () &&
-        (!(Attributes & EFI_VARIABLE_RUNTIME_ACCESS) || !(Attributes & EFI_VARIABLE_NON_VOLATILE))) {
-      return EFI_INVALID_PARAMETER;
-    }        
-    
-  } 
-
-  //
-  // Function part - create a new variable and copy the data.
-  // Both update a variable and create a variable will come here.  
-  // We can firstly write all the data in memory, then write them to file
-  // This can reduce the times of write operation
-  //
-  
-  NextVariable = (VARIABLE_HEADER *) mGlobal->Scratch;
-
-  NextVariable->StartId     = VARIABLE_DATA;
-  NextVariable->Attributes  = Attributes;
-  NextVariable->State       = VAR_ADDED;
-  NextVariable->Reserved    = 0;
-  VarNameOffset             = sizeof (VARIABLE_HEADER);
-  VarNameSize               = StrSize (VariableName);
-  CopyMem (
-    (UINT8 *) ((UINTN) NextVariable + VarNameOffset),
-    VariableName,
-    VarNameSize
-    );
-  VarDataOffset = VarNameOffset + VarNameSize + GET_PAD_SIZE (VarNameSize);
-  CopyMem (
-    (UINT8 *) ((UINTN) NextVariable + VarDataOffset),
-    Data,
-    DataSize
-    );
-  CopyMem (&NextVariable->VendorGuid, VendorGuid, sizeof (EFI_GUID));
-  //
-  // There will be pad bytes after Data, the NextVariable->NameSize and
-  // NextVariable->DataSize should not include pad size so that variable
-  // service can get actual size in GetVariable
-  //
-  NextVariable->NameSize  = (UINT32)VarNameSize;
-  NextVariable->DataSize  = (UINT32)DataSize;
-
-  //
-  // The actual size of the variable that stores in storage should
-  // include pad size.
-  // VarDataOffset: offset from begin of current variable header
-  //
-  VarSize = VarDataOffset + DataSize + GET_PAD_SIZE (DataSize);
-
-  StorageType = (Attributes & EFI_VARIABLE_NON_VOLATILE) ? NonVolatile : Volatile;
-
-  if ((UINT32) (VarSize + mGlobal->LastVariableOffset[StorageType]) >
-      ((VARIABLE_STORE_HEADER *) mGlobal->VariableBase[StorageType])->Size
-      ) {
-    if ((StorageType == NonVolatile) && EfiAtRuntime ()) {
-      return EFI_OUT_OF_RESOURCES;
-    }
-    //
-    // Perform garbage collection & reclaim operation
-    //
-    Status = Reclaim (StorageType, Variable->CurrPtr);
-    if (EFI_ERROR (Status)) {
-      //
-      // Reclaim error
-      // we cannot restore to original state, fetal error, report to user
-      //
-      DEBUG ((EFI_D_ERROR, "FSVariable: Recalim error (fetal error) - %r\n", Status));
-      return Status;
-    }
-    //
-    // If still no enough space, return out of resources
-    //
-    if ((UINT32) (VarSize + mGlobal->LastVariableOffset[StorageType]) >
-        ((VARIABLE_STORE_HEADER *) mGlobal->VariableBase[StorageType])->Size
-       ) {
-      return EFI_OUT_OF_RESOURCES;
-    }
-
-    Reclaimed = TRUE;
-  }
-  Status = mGlobal->VariableStore[StorageType]->Write (
-                                                  mGlobal->VariableStore[StorageType],
-                                                  mGlobal->LastVariableOffset[StorageType],
-                                                  VarSize,
-                                                  NextVariable
-                                                  );
-  //
-  // NOTE: Write operation at least can write data to memory cache
-  //       Discard file writing failure here.
-  //
-  mGlobal->LastVariableOffset[StorageType] += VarSize;
-
-  if ((Attributes & EFI_VARIABLE_HARDWARE_ERROR_RECORD) != 0) {
-    mGlobal->HwErrVariableTotalSize += VarSize;
-  } else {
-    mGlobal->CommonVariableTotalSize += VarSize;
-  }
-
-  //
-  // Mark the old variable as deleted
-  //
-  if (!Reclaimed && !EFI_ERROR (Status) && Variable->CurrPtr != NULL) {
-    State = Variable->CurrPtr->State;
-    State &= VAR_DELETED;
-
-    Status = mGlobal->VariableStore[StorageType]->Write (
-                                                    mGlobal->VariableStore[StorageType],
-                                                    VARIABLE_MEMBER_OFFSET (State, (UINTN) Variable->CurrPtr - (UINTN) Variable->StartPtr),
-                                                    sizeof (Variable->CurrPtr->State),
-                                                    &State
-                                                    );
-    //
-    // NOTE: Write operation at least can write data to memory cache
-    //       Discard file writing failure here.
-    //
-  }
-  return EFI_SUCCESS;
-}
-
-EFI_STATUS
-EFIAPI
-DuetGetVariable (
-  IN      CHAR16            *VariableName,
-  IN      EFI_GUID          *VendorGuid,
-  OUT     UINT32            *Attributes OPTIONAL,
-  IN OUT  UINTN             *DataSize,
-  OUT     VOID              *Data
-  )
-/*++
-
-Routine Description:
-
-  This code finds variable in storage blocks (Volatile or Non-Volatile)
-
-Arguments:
-
-  VariableName                    Name of Variable to be found
-  VendorGuid                      Variable vendor GUID
-  Attributes OPTIONAL             Attribute value of the variable found
-  DataSize                        Size of Data found. If size is less than the
-                                  data, this value contains the required size.
-  Data                            Data pointer
-
-Returns:
-
-  EFI STATUS
-
---*/
-{
-  VARIABLE_POINTER_TRACK  Variable;
-  UINTN                   VarDataSize;
-  EFI_STATUS              Status;
-
-  if (VariableName == NULL || VendorGuid == NULL || DataSize == NULL) {
-    return EFI_INVALID_PARAMETER;
-  }
-
-  //
-  // Find existing variable
-  //
-  Status = FindVariable (VariableName, VendorGuid, &Variable);
-
-  if (Variable.CurrPtr == NULL || EFI_ERROR (Status)) {
-    return Status;
-  }
-  //
-  // Get data size
-  //
-  VarDataSize = Variable.CurrPtr->DataSize;
-  if (*DataSize >= VarDataSize) {
-    if (Data == NULL) {
-      return EFI_INVALID_PARAMETER;
-    }
-    CopyMem (Data, GetVariableDataPtr (Variable.CurrPtr), VarDataSize);
-
-    if (Attributes != NULL) {
-      *Attributes = Variable.CurrPtr->Attributes;
-    }
-
-    *DataSize = VarDataSize;
-
-    return EFI_SUCCESS;
-  } else {
-    *DataSize = VarDataSize;
-    return EFI_BUFFER_TOO_SMALL;
-  }
-}
-
-EFI_STATUS
-EFIAPI
-GetNextVariableName (
-  IN OUT  UINTN             *VariableNameSize,
-  IN OUT  CHAR16            *VariableName,
-  IN OUT  EFI_GUID          *VendorGuid
-  )
-/*++
-
-Routine Description:
-
-  This code Finds the Next available variable
-
-Arguments:
-
-  VariableNameSize            Size of the variable
-  VariableName                Pointer to variable name
-  VendorGuid                  Variable Vendor Guid
-
-Returns:
-
-  EFI STATUS
-
---*/
-{
-  VARIABLE_POINTER_TRACK  Variable;
-  UINTN                   VarNameSize;
-  EFI_STATUS              Status;
-
-  if (VariableNameSize == NULL || VariableName == NULL || VendorGuid == NULL) {
-    return EFI_INVALID_PARAMETER;
-  }
-
-  Status = FindVariable (VariableName, VendorGuid, &Variable);
-
-  if (Variable.CurrPtr == NULL || EFI_ERROR (Status)) {
-    return Status;
-  }
-
-  if (VariableName[0] != 0) {
-    //
-    // If variable name is not NULL, get next variable
-    //
-    Variable.CurrPtr = GetNextVariablePtr (Variable.CurrPtr);
-  }
-
-  while (TRUE) {
-    //
-    // The order we find variable is: 1). NonVolatile; 2). Volatile
-    // If both volatile and non-volatile variable store are parsed,
-    // return not found
-    //
-    if (Variable.CurrPtr >= Variable.EndPtr || Variable.CurrPtr == NULL) {
-      if (Variable.Type == Volatile) {
-        //
-        // Since we met the end of Volatile storage, we have parsed all the stores.
-        //
-        return EFI_NOT_FOUND;
-      }
-
-      //
-      // End of NonVolatile, continue to parse Volatile
-      //
-      Variable.Type = Volatile;
-      Variable.StartPtr = (VARIABLE_HEADER *) ((VARIABLE_STORE_HEADER *) mGlobal->VariableBase[Volatile] + 1);
-      Variable.EndPtr   = (VARIABLE_HEADER *) GetEndPointer ((VARIABLE_STORE_HEADER *) mGlobal->VariableBase[Volatile]);
-
-      Variable.CurrPtr = Variable.StartPtr;
-      if (!IsValidVariableHeader (Variable.CurrPtr)) {
-        continue;
-      }
-    }
-    //
-    // Variable is found
-    //
-    if (IsValidVariableHeader (Variable.CurrPtr) &&
-        ((Variable.CurrPtr->State == VAR_ADDED) ||
-         (Variable.CurrPtr->State == (VAR_ADDED & VAR_IN_DELETED_TRANSITION)))) {
-      if (!EfiAtRuntime () || (Variable.CurrPtr->Attributes & EFI_VARIABLE_RUNTIME_ACCESS)) {
-        VarNameSize = Variable.CurrPtr->NameSize;
-        if (VarNameSize <= *VariableNameSize) {
-          CopyMem (
-            VariableName,
-            GET_VARIABLE_NAME_PTR (Variable.CurrPtr),
-            VarNameSize
-            );
-          CopyMem (
-            VendorGuid,
-            &Variable.CurrPtr->VendorGuid,
-            sizeof (EFI_GUID)
-            );
-          Status = EFI_SUCCESS;
-        } else {
-          Status = EFI_BUFFER_TOO_SMALL;
-        }
-
-        *VariableNameSize = VarNameSize;
-        return Status;
-      }
-    }
-
-    Variable.CurrPtr = GetNextVariablePtr (Variable.CurrPtr);
-  }
-}
-
-EFI_STATUS
-EFIAPI
-SetVariable (
-  IN CHAR16                  *VariableName,
-  IN EFI_GUID                *VendorGuid,
-  IN UINT32                  Attributes,
-  IN UINTN                   DataSize,
-  IN VOID                    *Data
-  )
-/*++
-
-Routine Description:
-
-  This code sets variable in storage blocks (Volatile or Non-Volatile)
-
-Arguments:
-
-  VariableName                    Name of Variable to be found
-  VendorGuid                      Variable vendor GUID
-  Attributes                      Attribute value of the variable found
-  DataSize                        Size of Data found. If size is less than the
-                                  data, this value contains the required size.
-  Data                            Data pointer
-
-Returns:
-  
-  EFI_INVALID_PARAMETER           - Invalid parameter
-  EFI_SUCCESS                     - Set successfully
-  EFI_OUT_OF_RESOURCES            - Resource not enough to set variable
-  EFI_NOT_FOUND                   - Not found
-  EFI_DEVICE_ERROR                - Variable can not be saved due to hardware failure
-  EFI_WRITE_PROTECTED             - Variable is read-only
-
---*/
-{
-  VARIABLE_POINTER_TRACK  Variable;
-  EFI_STATUS              Status;
-
-  //
-  // Check input parameters
-  // 
-  if (VariableName == NULL || VariableName[0] == 0 || VendorGuid == NULL) {
-    return EFI_INVALID_PARAMETER;
-  }
-  
-  if (DataSize != 0 && Data == NULL) {
-    return EFI_INVALID_PARAMETER;
-  }
-
-  //
-  // Not support authenticated variable write yet.
-  //
-  if ((Attributes & EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS) != 0) {
-    return EFI_INVALID_PARAMETER;
-  }
-
-  //
-  //  Make sure if runtime bit is set, boot service bit is set also
-  //
-  if ((Attributes & (EFI_VARIABLE_RUNTIME_ACCESS | EFI_VARIABLE_BOOTSERVICE_ACCESS)) == EFI_VARIABLE_RUNTIME_ACCESS) {
-    return EFI_INVALID_PARAMETER;
-  }
-  
-  //
-  //  The size of the VariableName, including the Unicode Null in bytes plus
-  //  the DataSize is limited to maximum size of PcdGet32 (PcdMaxHardwareErrorVariableSize)
-  //  bytes for HwErrRec, and PcdGet32 (PcdMaxVariableSize) bytes for the others.
-  //
-  if ((Attributes & EFI_VARIABLE_HARDWARE_ERROR_RECORD) == EFI_VARIABLE_HARDWARE_ERROR_RECORD) {
-    if ((DataSize > PcdGet32(PcdMaxHardwareErrorVariableSize)) ||                                                       
-        (sizeof (VARIABLE_HEADER) + StrSize (VariableName) + DataSize > PcdGet32(PcdMaxHardwareErrorVariableSize))) {
-      return EFI_INVALID_PARAMETER;
-    }
-    //
-    // According to UEFI spec, HARDWARE_ERROR_RECORD variable name convention should be L"HwErrRecXXXX"
-    //
-    if (StrnCmp(VariableName, L"HwErrRec", StrLen(L"HwErrRec")) != 0) {
-      return EFI_INVALID_PARAMETER;
-    }
-  } else {
-    if ((DataSize > PcdGet32(PcdMaxVariableSize)) ||
-        (sizeof (VARIABLE_HEADER) + StrSize (VariableName) + DataSize > PcdGet32(PcdMaxVariableSize))) {
-      return EFI_INVALID_PARAMETER;
-    }  
-  }  
-
-  //
-  // Check whether the input variable is already existed
-  //
-  Status = FindVariable (VariableName, VendorGuid, &Variable);
-
-  //
-  // Hook the operation of setting PlatformLangCodes/PlatformLang and LangCodes/Lang
-  //
-  AutoUpdateLangVariable (VariableName, Data, DataSize);
-
-  Status = UpdateVariable (VariableName, VendorGuid, Data, DataSize, Attributes, &Variable);
-
-  return Status;
-}
-
-EFI_STATUS
-EFIAPI
-QueryVariableInfo (
-  IN  UINT32                 Attributes,
-  OUT UINT64                 *MaximumVariableStorageSize,
-  OUT UINT64                 *RemainingVariableStorageSize,
-  OUT UINT64                 *MaximumVariableSize
-  )
-/*++
-
-Routine Description:
-
-  This code returns information about the EFI variables.
-
-Arguments:
-
-  Attributes                      Attributes bitmask to specify the type of variables
-                                  on which to return information.
-  MaximumVariableStorageSize      Pointer to the maximum size of the storage space available
-                                  for the EFI variables associated with the attributes specified.
-  RemainingVariableStorageSize    Pointer to the remaining size of the storage space available
-                                  for the EFI variables associated with the attributes specified.
-  MaximumVariableSize             Pointer to the maximum size of the individual EFI variables
-                                  associated with the attributes specified.
-
-Returns:
-
-  EFI STATUS
-  EFI_INVALID_PARAMETER           - An invalid combination of attribute bits was supplied.
-  EFI_SUCCESS                     - Query successfully.
-  EFI_UNSUPPORTED                 - The attribute is not supported on this platform.
-
---*/
-{
-  VARIABLE_HEADER        *Variable;
-  VARIABLE_HEADER        *NextVariable;
-  UINT64                 VariableSize;
-  VARIABLE_STORE_HEADER  *VariableStoreHeader;
-  UINT64                 CommonVariableTotalSize;
-  UINT64                 HwErrVariableTotalSize;
-
-  CommonVariableTotalSize = 0;
-  HwErrVariableTotalSize = 0;
-
-  if(MaximumVariableStorageSize == NULL || RemainingVariableStorageSize == NULL || MaximumVariableSize == NULL || Attributes == 0) {
-    return EFI_INVALID_PARAMETER;
-  }
-  
-  if((Attributes & (EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS | EFI_VARIABLE_HARDWARE_ERROR_RECORD)) == 0) {
-    //
-    // Make sure the Attributes combination is supported by the platform.
-    //
-    return EFI_UNSUPPORTED;  
-  } else if ((Attributes & (EFI_VARIABLE_RUNTIME_ACCESS | EFI_VARIABLE_BOOTSERVICE_ACCESS)) == EFI_VARIABLE_RUNTIME_ACCESS) {
-    //
-    // Make sure if runtime bit is set, boot service bit is set also.
-    //
-    return EFI_INVALID_PARAMETER;
-  } else if (EfiAtRuntime () && !(Attributes & EFI_VARIABLE_RUNTIME_ACCESS)) {
-    //
-    // Make sure RT Attribute is set if we are in Runtime phase.
-    //
-    return EFI_INVALID_PARAMETER;
-  } else if ((Attributes & (EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_HARDWARE_ERROR_RECORD)) == EFI_VARIABLE_HARDWARE_ERROR_RECORD) {
-    //
-    // Make sure Hw Attribute is set with NV.
-    //
-    return EFI_INVALID_PARAMETER;
-  } else if ((Attributes & EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS) != 0) {
-    //
-    // Not support authentiated variable write yet.
-    //
-    return EFI_UNSUPPORTED;
-  }
-  
-  VariableStoreHeader = (VARIABLE_STORE_HEADER *) mGlobal->VariableBase[
-                                (Attributes & EFI_VARIABLE_NON_VOLATILE) ? NonVolatile : Volatile
-                                ];
-  //
-  // Now let's fill *MaximumVariableStorageSize *RemainingVariableStorageSize
-  // with the storage size (excluding the storage header size).
-  //
-  *MaximumVariableStorageSize   = VariableStoreHeader->Size - sizeof (VARIABLE_STORE_HEADER);
-
-  //
-  // Harware error record variable needs larger size.
-  //
-  if ((Attributes & (EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_HARDWARE_ERROR_RECORD)) == (EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_HARDWARE_ERROR_RECORD)) {
-    *MaximumVariableStorageSize = PcdGet32(PcdHwErrStorageSize);
-    *MaximumVariableSize = PcdGet32(PcdMaxHardwareErrorVariableSize) - sizeof (VARIABLE_HEADER);
-  } else {
-    if ((Attributes & EFI_VARIABLE_NON_VOLATILE) != 0) {
-      ASSERT (PcdGet32(PcdHwErrStorageSize) < VariableStoreHeader->Size);
-      *MaximumVariableStorageSize = VariableStoreHeader->Size - sizeof (VARIABLE_STORE_HEADER) - PcdGet32(PcdHwErrStorageSize);
-    }
-
-    //
-    // Let *MaximumVariableSize be PcdGet32(PcdMaxVariableSize) with the exception of the variable header size.
-    //
-    *MaximumVariableSize = PcdGet32(PcdMaxVariableSize) - sizeof (VARIABLE_HEADER);
-  }
-  
-  //
-  // Point to the starting address of the variables.
-  //
-  Variable = (VARIABLE_HEADER *) (VariableStoreHeader + 1);
-
-  //
-  // Now walk through the related variable store.
-  //
-  while ((Variable < GetEndPointer (VariableStoreHeader)) && IsValidVariableHeader (Variable)) {
-    NextVariable = GetNextVariablePtr (Variable);
-    VariableSize = (UINT64) (UINTN) NextVariable - (UINT64) (UINTN) Variable;
-
-    if (EfiAtRuntime ()) {
-      //
-      // we don't take the state of the variables in mind
-      // when calculating RemainingVariableStorageSize,
-      // since the space occupied by variables not marked with
-      // VAR_ADDED is not allowed to be reclaimed in Runtime.
-      //
-      if ((Variable->Attributes & EFI_VARIABLE_HARDWARE_ERROR_RECORD) == EFI_VARIABLE_HARDWARE_ERROR_RECORD) {
-        HwErrVariableTotalSize += VariableSize;
-      } else {
-        CommonVariableTotalSize += VariableSize;
-      }
-    } else {
-      //
-      // Only care about Variables with State VAR_ADDED,because
-      // the space not marked as VAR_ADDED is reclaimable now.
-      //
-      if ((Variable->State == VAR_ADDED) || (Variable->State == (VAR_ADDED & VAR_IN_DELETED_TRANSITION))) {
-        if ((Variable->Attributes & EFI_VARIABLE_HARDWARE_ERROR_RECORD) == EFI_VARIABLE_HARDWARE_ERROR_RECORD) {
-          HwErrVariableTotalSize += VariableSize;
-        } else {
-          CommonVariableTotalSize += VariableSize;
-        }
-      }
-    }
-
-    //
-    // Go to the next one
-    //
-    Variable = NextVariable;
-  }
-  
-  if ((Attributes  & EFI_VARIABLE_HARDWARE_ERROR_RECORD) == EFI_VARIABLE_HARDWARE_ERROR_RECORD){
-    *RemainingVariableStorageSize = *MaximumVariableStorageSize - HwErrVariableTotalSize;
-  } else {
-    *RemainingVariableStorageSize = *MaximumVariableStorageSize - CommonVariableTotalSize;
-  }
-
-  return EFI_SUCCESS;
-}
-
-EFI_STATUS
-EFIAPI
-VariableServiceInitialize (
-  IN EFI_HANDLE         ImageHandle,
-  IN EFI_SYSTEM_TABLE   *SystemTable
-  )
-/*++
-
-Routine Description:
-  This function does initialization for variable services
-
-Arguments:
-
-  ImageHandle   - The firmware allocated handle for the EFI image.
-  SystemTable   - A pointer to the EFI System Table.
-
-Returns:
-
-  Status code.
-
-  EFI_NOT_FOUND     - Variable store area not found.
-  EFI_SUCCESS       - Variable services successfully initialized.
-
---*/
-{
-  EFI_STATUS                      Status;
-  EFI_HANDLE                      NewHandle;
-  VS_DEV                          *Dev;
-  EFI_PEI_HOB_POINTERS            GuidHob;
-  VARIABLE_HEADER                 *Variable;
-  VARIABLE_HEADER                 *NextVariable;
-  VARIABLE_STORE_HEADER           *VariableStoreHeader;
-  EFI_FLASH_MAP_FS_ENTRY_DATA     *FlashMapEntryData;
-  EFI_FLASH_SUBAREA_ENTRY         VariableStoreEntry;
-  UINT64                          BaseAddress;
-  UINT64                          Length;
-  EFI_GCD_MEMORY_SPACE_DESCRIPTOR GcdDescriptor;
-
-  Status = gBS->AllocatePool (
-                  EfiRuntimeServicesData,
-                  (UINTN) sizeof (VARIABLE_GLOBAL),
-                  (VOID**) &mGlobal
-                  );
-  if (EFI_ERROR (Status)) {
-    return Status;
-  }
-
-  ZeroMem (mGlobal, (UINTN) sizeof (VARIABLE_GLOBAL));
-
-  GuidHob.Raw = GetHobList ();
-  FlashMapEntryData = NULL;
-  while ((GuidHob.Raw = GetNextGuidHob (&gEfiFlashMapHobGuid, GuidHob.Raw)) != NULL) {
-    FlashMapEntryData = (EFI_FLASH_MAP_FS_ENTRY_DATA *) GET_GUID_HOB_DATA (GuidHob.Guid);
-    if (FlashMapEntryData->AreaType == EFI_FLASH_AREA_EFI_VARIABLES) {
-      break;
-    }
-    GuidHob.Raw = GET_NEXT_HOB (GuidHob); 
-  }
-
-  if (FlashMapEntryData == NULL) {
-    DEBUG ((EFI_D_ERROR, "FSVariable: Could not find flash area for variable!\n"));
-    Status = EFI_NOT_FOUND;
-    return Status;
-  }
-  
-  CopyMem(
-    (VOID*)&VariableStoreEntry,
-    (VOID*)&FlashMapEntryData->Entries[0],
-    sizeof(EFI_FLASH_SUBAREA_ENTRY)
-    );
-
-  //
-  // Mark the variable storage region of the FLASH as RUNTIME
-  //
-  BaseAddress = VariableStoreEntry.Base & (~EFI_PAGE_MASK);
-  Length      = VariableStoreEntry.Length + (VariableStoreEntry.Base - BaseAddress);
-  Length      = (Length + EFI_PAGE_SIZE - 1) & (~EFI_PAGE_MASK);
-  Status      = gDS->GetMemorySpaceDescriptor (BaseAddress, &GcdDescriptor);
-  if (EFI_ERROR (Status)) {
-    Status = EFI_UNSUPPORTED;
-    return Status;
-  }
-  Status = gDS->SetMemorySpaceAttributes (
-                  BaseAddress,
-                  Length,
-                  GcdDescriptor.Attributes | EFI_MEMORY_RUNTIME
-                  );
-  if (EFI_ERROR (Status)) {
-    Status = EFI_UNSUPPORTED;
-    return Status;
-  }
-
-  Status = FileStorageConstructor (
-             &mGlobal->VariableStore[NonVolatile], 
-             &mGlobal->GoVirtualChildEvent[NonVolatile],
-             VariableStoreEntry.Base,
-             (UINT32) VariableStoreEntry.Length,
-             FlashMapEntryData->VolumeId,
-             FlashMapEntryData->FilePath
-             );
-  ASSERT_EFI_ERROR (Status);
-
-  //
-  // Volatile Storage
-  //
-  Status = MemStorageConstructor (
-             &mGlobal->VariableStore[Volatile],
-             &mGlobal->GoVirtualChildEvent[Volatile],
-             VOLATILE_VARIABLE_STORE_SIZE
-             );
-  ASSERT_EFI_ERROR (Status);
-
-  //
-  // Scratch
-  //
-  Status = gBS->AllocatePool (
-                  EfiRuntimeServicesData,
-                  VARIABLE_SCRATCH_SIZE,
-                  &mGlobal->Scratch
-                  );
-  ASSERT_EFI_ERROR (Status);
-
-  //
-  // 1. NV Storage
-  //
-  Dev = DEV_FROM_THIS (mGlobal->VariableStore[NonVolatile]);
-  VariableStoreHeader = (VARIABLE_STORE_HEADER *) VAR_DATA_PTR (Dev);
-  if (GetVariableStoreStatus (VariableStoreHeader) == EfiValid) {
-    if (~VariableStoreHeader->Size == 0) {
-      VariableStoreHeader->Size = (UINT32) VariableStoreEntry.Length;
-    }
-  }
-  //
-  // Calculate LastVariableOffset
-  //
-  Variable = (VARIABLE_HEADER *) (VariableStoreHeader + 1);
-  while (IsValidVariableHeader (Variable)) {
-    UINTN VariableSize = 0;
-    NextVariable = GetNextVariablePtr (Variable);
-    VariableSize = NextVariable - Variable;
-    if ((NextVariable->Attributes & (EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_HARDWARE_ERROR_RECORD)) == (EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_HARDWARE_ERROR_RECORD)) {
-      mGlobal->HwErrVariableTotalSize += HEADER_ALIGN (VariableSize);
-    } else {
-      mGlobal->CommonVariableTotalSize += HEADER_ALIGN (VariableSize);
-    }
-    Variable = NextVariable;
-  }
-
-  mGlobal->LastVariableOffset[NonVolatile] = (UINTN) Variable - (UINTN) VariableStoreHeader;
-  mGlobal->VariableBase[NonVolatile]       = VariableStoreHeader;
-
-  //
-  // Reclaim if remaining space is too small
-  //
-  if ((VariableStoreHeader->Size - mGlobal->LastVariableOffset[NonVolatile]) < VARIABLE_RECLAIM_THRESHOLD) {
-    Status = Reclaim (NonVolatile, NULL);
-    if (EFI_ERROR (Status)) {
-      //
-      // Reclaim error
-      // we cannot restore to original state
-      //
-      DEBUG ((EFI_D_ERROR, "FSVariable: Reclaim error (fatal error) - %r\n", Status));
-      ASSERT_EFI_ERROR (Status);
-    }
-  }
-  
-  //
-  // 2. Volatile Storage
-  //
-  Dev = DEV_FROM_THIS (mGlobal->VariableStore[Volatile]);
-  VariableStoreHeader = (VARIABLE_STORE_HEADER *) VAR_DATA_PTR (Dev);
-  mGlobal->VariableBase[Volatile] = VAR_DATA_PTR (Dev);  
-  mGlobal->LastVariableOffset[Volatile] = sizeof (VARIABLE_STORE_HEADER);
-  //
-  // init store_header & body in memory.
-  //
-  mGlobal->VariableStore[Volatile]->Erase (mGlobal->VariableStore[Volatile]);
-  mGlobal->VariableStore[Volatile]->Write (
-                                   mGlobal->VariableStore[Volatile],
-                                   0,
-                                   sizeof (VARIABLE_STORE_HEADER),
-                                   &mStoreHeaderTemplate
-                                   );
-
-
-  SystemTable->RuntimeServices->GetVariable         = DuetGetVariable;
-  SystemTable->RuntimeServices->GetNextVariableName = GetNextVariableName;
-  SystemTable->RuntimeServices->SetVariable         = SetVariable;
-
-  SystemTable->RuntimeServices->QueryVariableInfo   = QueryVariableInfo;
-
-  //
-  // Now install the Variable Runtime Architectural Protocol on a new handle
-  //
-  NewHandle = NULL;
-  Status = gBS->InstallMultipleProtocolInterfaces (
-                  &NewHandle,
-                  &gEfiVariableArchProtocolGuid,
-                  NULL,
-                  &gEfiVariableWriteArchProtocolGuid,
-                  NULL,
-                  NULL
-                  );
-  ASSERT_EFI_ERROR (Status);
-
-  return Status;
-}
-
-
-
-VOID
-EFIAPI
-OnVirtualAddressChangeFsv (
-  IN EFI_EVENT        Event,
-  IN VOID             *Context
-  )
-{
-  UINTN Index;
-
-  for (Index = 0; Index < MaxType; Index++) {
-    mGlobal->GoVirtualChildEvent[Index] (Event, mGlobal->VariableStore[Index]);
-    EfiConvertPointer (0, (VOID**) &mGlobal->VariableStore[Index]);
-    EfiConvertPointer (0, &mGlobal->VariableBase[Index]);
-  }
-  EfiConvertPointer (0, (VOID **) &mGlobal->PlatformLangCodes);
-  EfiConvertPointer (0, (VOID **) &mGlobal->LangCodes);
-  EfiConvertPointer (0, (VOID **) &mGlobal->PlatformLang);
-  EfiConvertPointer (0, &mGlobal->Scratch);
-  EfiConvertPointer (0, (VOID**) &mGlobal);
-}
Index: DuetPkg/FSVariable/FSVariable.h
===================================================================
--- DuetPkg/FSVariable/FSVariable.h	(revision 1)
+++ DuetPkg/FSVariable/FSVariable.h	(working copy)
@@ -1,156 +0,0 @@
-/*++
-
-Copyright (c) 2006 - 2010, Intel Corporation. All rights reserved.<BR>
-This program and the accompanying materials                          
-are licensed and made available under the terms and conditions of the BSD License         
-which accompanies this distribution.  The full text of the license may be found at        
-http://opensource.org/licenses/bsd-license.php                                            
-                                                                                          
-THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,                     
-WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.             
-
-Module Name:
-
-  FSVariable.h
-  
-Abstract:
-
---*/
-
-#ifndef _FS_VARIABLE_H
-#define _FS_VARIABLE_H
-
-//
-// Statements that include other header files
-//
-#include <PiDxe.h>
-
-#include <Library/BaseLib.h>
-#include <Library/PcdLib.h>
-#include <Library/BaseMemoryLib.h>
-#include <Library/MemoryAllocationLib.h>
-#include <Library/UefiBootServicesTableLib.h>
-#include <Library/UefiRuntimeLib.h>
-#include <Library/DebugLib.h>
-#include <Library/UefiLib.h>
-#include <Library/HobLib.h>
-#include <Library/DxeServicesTableLib.h>
-#include <Library/DevicePathLib.h>
-
-#include <Guid/HobList.h>
-#include <Guid/FlashMapHob.h>
-#include <Guid/VariableFormat.h>
-#include <Guid/GlobalVariable.h>
-#include <Protocol/Variable.h>
-#include <Protocol/VariableWrite.h>
-#include <Protocol/SimpleFileSystem.h>
-#include <Protocol/BlockIo.h>
-
-
-#include "EfiFlashMap.h"
-#include "VariableStorage.h"
-
-#define VOLATILE_VARIABLE_STORE_SIZE  FixedPcdGet32(PcdVariableStoreSize)
-#define VARIABLE_SCRATCH_SIZE         MAX(FixedPcdGet32(PcdMaxVariableSize), FixedPcdGet32(PcdMaxHardwareErrorVariableSize))
-#define VARIABLE_RECLAIM_THRESHOLD    (1024)
-///
-/// The size of a 3 character ISO639 language code.
-///
-#define ISO_639_2_ENTRY_SIZE    3
-
-#define GET_VARIABLE_NAME_PTR(a)  (CHAR16 *) ((UINTN) (a) + sizeof (VARIABLE_HEADER))
-
-typedef enum {
-  Physical,
-  Virtual
-} VARIABLE_POINTER_TYPE;
-
-typedef enum {
-  NonVolatile,
-  Volatile,
-  MaxType
-} VARIABLE_STORAGE_TYPE;
-
-typedef struct {
-  VARIABLE_HEADER         *CurrPtr;
-  VARIABLE_HEADER         *EndPtr;
-  VARIABLE_HEADER         *StartPtr;
-  VARIABLE_STORAGE_TYPE   Type;
-} VARIABLE_POINTER_TRACK;
-
-#define VARIABLE_MEMBER_OFFSET(Member, StartOffset) \
-        ( sizeof (VARIABLE_STORE_HEADER) + (StartOffset) + \
-          (UINTN) ((UINT8 *) &((VARIABLE_HEADER*) 0)->Member - (UINT8 *) &((VARIABLE_HEADER*) 0)->StartId) \
-        )
-
-
-typedef struct {
-  EFI_EVENT_NOTIFY   GoVirtualChildEvent[MaxType];
-  VARIABLE_STORAGE   *VariableStore[MaxType];       // Instance of VariableStorage
-  VOID               *VariableBase[MaxType];        // Start address of variable storage
-  UINTN              LastVariableOffset[MaxType];   // The position to write new variable to (index from VariableBase)
-  VOID               *Scratch;                      // Buffer used during reclaim
-  UINTN              CommonVariableTotalSize;
-  UINTN              HwErrVariableTotalSize;
-  CHAR8              *PlatformLangCodes;
-  CHAR8              *LangCodes;
-  CHAR8              *PlatformLang;
-  CHAR8              Lang[ISO_639_2_ENTRY_SIZE + 1];
-} VARIABLE_GLOBAL;
-
-//
-// Functions
-//
-
-EFI_STATUS
-EFIAPI
-VariableServiceInitialize (
-  IN EFI_HANDLE         ImageHandle,
-  IN EFI_SYSTEM_TABLE   *SystemTable
-  );
-
-VOID
-EFIAPI
-VariableClassAddressChangeEvent (
-  IN EFI_EVENT        Event,
-  IN VOID             *Context
-  );
-
-EFI_STATUS
-EFIAPI
-DuetGetVariable (
-  IN      CHAR16            *VariableName,
-  IN      EFI_GUID          *VendorGuid,
-  OUT     UINT32            *Attributes OPTIONAL,
-  IN OUT  UINTN             *DataSize,
-  OUT     VOID              *Data
-  );
-
-EFI_STATUS
-EFIAPI
-GetNextVariableName (
-  IN OUT  UINTN             *VariableNameSize,
-  IN OUT  CHAR16            *VariableName,
-  IN OUT  EFI_GUID          *VendorGuid
-  );
-
-EFI_STATUS
-EFIAPI
-SetVariable (
-  IN CHAR16                  *VariableName,
-  IN EFI_GUID                *VendorGuid,
-  IN UINT32                  Attributes,
-  IN UINTN                   DataSize,
-  IN VOID                    *Data
-  );
-
-EFI_STATUS
-EFIAPI
-QueryVariableInfo (
-  IN  UINT32                 Attributes,
-  OUT UINT64                 *MaximumVariableStorageSize,
-  OUT UINT64                 *RemainingVariableStorageSize,
-  OUT UINT64                 *MaximumVariableSize
-  );
-
-#endif
Index: DuetPkg/FSVariable/FSVariable.inf
===================================================================
--- DuetPkg/FSVariable/FSVariable.inf	(revision 1)
+++ DuetPkg/FSVariable/FSVariable.inf	(working copy)
@@ -1,74 +0,0 @@
-## @file
-#
-# Copyright (c) 2006 - 2010, Intel Corporation. All rights reserved.<BR>
-# This program and the accompanying materials                          
-# are licensed and made available under the terms and conditions of the BSD License         
-# which accompanies this distribution.  The full text of the license may be found at        
-# http://opensource.org/licenses/bsd-license.php                                            
-#                                                                                           
-# THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,                     
-# WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.             
-# 
-#  Module Name:
-#
-#   FSVariable.inf
-#
-#  Abstract:
-#
-#    Component description file for variable module
-#
-##
-
-[Defines]
-  INF_VERSION                    = 0x00010005
-  BASE_NAME                      = FSVariable
-  FILE_GUID                      = A36495C1-C205-414e-B71F-4BE3476D699C
-  MODULE_TYPE                    = DXE_RUNTIME_DRIVER
-  VERSION_STRING                 = 1.0
-  ENTRY_POINT                    = VariableServiceInitialize
-  
-[Packages]
-  MdePkg/MdePkg.dec
-  DuetPkg/DuetPkg.dec
-  MdeModulePkg/MdeModulePkg.dec
-
-[Sources]
-  FSVariable.h
-  VariableStorage.h
-  FSVariable.c
-  FileStorage.c
-  MemStorage.c
-
-[LibraryClasses]
-  PcdLib
-  BaseMemoryLib
-  BaseLib
-  UefiBootServicesTableLib
-  UefiRuntimeLib
-  DebugLib
-  UefiLib
-  HobLib
-  DxeServicesTableLib
-  DevicePathLib
-  UefiDriverEntryPoint
-  MemoryAllocationLib
-
-[Guids]
-  gEfiFlashMapHobGuid
-  gEfiVariableGuid
-  gEfiGlobalVariableGuid                        ## PRODUCES ## Variable Guid
-  
-[Protocols]
-  gEfiVariableArchProtocolGuid
-  gEfiVariableWriteArchProtocolGuid
-  gEfiSimpleFileSystemProtocolGuid
-  gEfiBlockIoProtocolGuid
-
-[Pcd]
-  gEfiMdeModulePkgTokenSpaceGuid.PcdMaxVariableSize
-  gEfiMdeModulePkgTokenSpaceGuid.PcdMaxHardwareErrorVariableSize
-  gEfiMdeModulePkgTokenSpaceGuid.PcdVariableStoreSize
-  gEfiMdeModulePkgTokenSpaceGuid.PcdHwErrStorageSize
-
-[Depex]
-  TRUE
Index: DuetPkg/FSVariable/FileStorage.c
===================================================================
--- DuetPkg/FSVariable/FileStorage.c	(revision 1)
+++ DuetPkg/FSVariable/FileStorage.c	(working copy)
@@ -1,431 +0,0 @@
-/*++
-
-Copyright (c) 2006 - 2010, Intel Corporation. All rights reserved.<BR>
-This program and the accompanying materials
-are licensed and made available under the terms and conditions of the BSD License
-which accompanies this distribution.  The full text of the license may be found at
-http://opensource.org/licenses/bsd-license.php
-
-THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-Module Name:
-
-    FileStorage.c
-
-Abstract:
-
-    handles variable store/reads on file
-
-Revision History
-
---*/
-#include "FSVariable.h"
-
-VOID             *mSFSRegistration;
-
-//
-// Prototypes
-//
-
-VOID
-EFIAPI
-OnVirtualAddressChangeFs (
-  IN EFI_EVENT            Event,
-  IN VOID                 *Context
-  );
-
-EFI_STATUS
-EFIAPI
-FileEraseStore(
-  IN VARIABLE_STORAGE     *This
-  );
-
-EFI_STATUS
-EFIAPI
-FileWriteStore (
-  IN VARIABLE_STORAGE     *This,
-  IN UINTN                Offset,
-  IN UINTN                BufferSize,
-  IN VOID                 *Buffer
-  );
-
-EFI_STATUS
-OpenStore (
-  IN  EFI_DEVICE_PATH_PROTOCOL  *Device,
-  IN  CHAR16                    *FilePathName,
-  IN  UINT64                    OpenMode,
-  OUT EFI_FILE_PROTOCOL         **File
-  );
-
-//
-// Implementation below:
-//
-VOID
-FileClose (
-  IN  EFI_FILE_PROTOCOL          *File
-  )
-{
-  EFI_STATUS Status;
-
-  Status = File->Flush (File);
-  ASSERT_EFI_ERROR (Status);
-
-  Status = File->Close (File);
-  ASSERT_EFI_ERROR (Status);
-}
-
-EFI_STATUS
-CheckStore (
-  IN  EFI_HANDLE                 SimpleFileSystemHandle,
-  IN  UINT32                     VolumeId,
-  OUT EFI_DEVICE_PATH_PROTOCOL   **Device
-  )
-{
-#define BLOCK_SIZE              0x200
-#define FAT16_VOLUME_ID_OFFSET  39
-#define FAT32_VOLUME_ID_OFFSET  67
-  EFI_STATUS                      Status;
-  EFI_BLOCK_IO_PROTOCOL           *BlkIo;
-  UINT8                           BootSector[BLOCK_SIZE];
-
-  *Device = NULL;
-  Status  = gBS->HandleProtocol (
-                   SimpleFileSystemHandle,
-                   &gEfiBlockIoProtocolGuid, // BlockIo should be supported if it supports SimpleFileSystem
-                   (VOID*)&BlkIo
-                   );
-
-  if (EFI_ERROR (Status)) {
-    goto ErrHandle;
-  }
-  if (!BlkIo->Media->MediaPresent) {
-    DEBUG ((EFI_D_ERROR, "FileStorage: Media not present!\n"));
-    Status = EFI_NO_MEDIA;
-    goto ErrHandle;
-  }
-  if (BlkIo->Media->ReadOnly) {
-    DEBUG ((EFI_D_ERROR, "FileStorage: Media is read-only!\n"));
-    Status = EFI_ACCESS_DENIED;
-    goto ErrHandle;
-  }
-
-  Status = BlkIo->ReadBlocks(
-                    BlkIo,
-                    BlkIo->Media->MediaId,
-                    0,
-                    BLOCK_SIZE,
-                    BootSector
-                    );
-  ASSERT_EFI_ERROR (Status);
-  if ((*(UINT32 *) &BootSector[FAT16_VOLUME_ID_OFFSET] != VolumeId) &&
-      (*(UINT32 *) &BootSector[FAT32_VOLUME_ID_OFFSET] != VolumeId)
-      ) {
-    Status = EFI_NOT_FOUND;
-    goto ErrHandle;
-  }
-
-  *Device = DuplicateDevicePath (DevicePathFromHandle (SimpleFileSystemHandle));
-  ASSERT (*Device != NULL);
-
-ErrHandle:
-  return Status;
-}
-
-EFI_STATUS
-CheckStoreExists (
-  IN  EFI_DEVICE_PATH_PROTOCOL   *Device
-  )
-{
-  EFI_HANDLE                        Handle;
-  EFI_SIMPLE_FILE_SYSTEM_PROTOCOL   *Volume;
-  EFI_STATUS                        Status;
-
-  Status = gBS->LocateDevicePath (
-                  &gEfiSimpleFileSystemProtocolGuid,
-                  &Device, 
-                  &Handle
-                  );
-
-  if (EFI_ERROR (Status)) {
-    return Status;
-  }
-
-  Status = gBS->HandleProtocol (
-                  Handle,
-                  &gEfiSimpleFileSystemProtocolGuid,
-                  (VOID **) &Volume
-                  );
-  if (EFI_ERROR (Status)) {
-    return Status;
-  }
-
-  return EFI_SUCCESS;
-}
-
-// this routine is still running in BS period, no limitation
-// call FileInitStorage(), which load variable content file to memory
-// read the store_header, init store_header if it has not been inited (read sth. about format/heathy)
-// reclaim space using scratch memory
-
-VOID
-EFIAPI
-OnSimpleFileSystemInstall (
-  IN EFI_EVENT        Event,
-  IN VOID             *Context
-  )
-{
-  EFI_STATUS                Status;
-  UINTN                     HandleSize;
-  EFI_HANDLE                Handle;
-  EFI_DEVICE_PATH_PROTOCOL  *Device;
-  VS_DEV                    *Dev;
-  EFI_FILE_PROTOCOL         *File;
-  UINTN                     NumBytes;
-
-  Dev = (VS_DEV *) Context;
-  
-  if (VAR_FILE_DEVICEPATH (Dev) != NULL &&
-      !EFI_ERROR (CheckStoreExists (VAR_FILE_DEVICEPATH (Dev)))
-     ) {
-    DEBUG ((EFI_D_ERROR, "FileStorage: Already mapped!\n"));
-    return ;
-  }
-
-  while (TRUE) {
-    HandleSize = sizeof (EFI_HANDLE);
-    Status = gBS->LocateHandle (
-                    ByRegisterNotify,
-                    NULL,
-                    mSFSRegistration,
-                    &HandleSize,
-                    &Handle
-                    );
-    if (EFI_ERROR (Status)) {
-      return ;
-    }
-    
-    Status = CheckStore (Handle, VAR_FILE_VOLUMEID (Dev), &Device);
-    if (!EFI_ERROR (Status)) {
-      break;
-    }
-  }
-
-  VAR_FILE_DEVICEPATH (Dev) = Device;
-  Status = OpenStore (
-             VAR_FILE_DEVICEPATH (Dev), 
-             VAR_FILE_FILEPATH (Dev), 
-             EFI_FILE_MODE_WRITE | EFI_FILE_MODE_READ | EFI_FILE_MODE_CREATE,
-             &File
-             );
-  ASSERT_EFI_ERROR (Status);
-  
-  NumBytes = Dev->Size;
-  Status = File->Write (File, &NumBytes, VAR_DATA_PTR (Dev));
-  ASSERT_EFI_ERROR (Status);
-  FileClose (File);
-  DEBUG ((EFI_D_ERROR, "FileStorage: Mapped to file!\n"));
-}
-
-EFI_STATUS
-FileStorageConstructor (
-  OUT VARIABLE_STORAGE      **VarStore,
-  OUT EFI_EVENT_NOTIFY      *GoVirtualEvent,
-  IN  EFI_PHYSICAL_ADDRESS  NvStorageBase,
-  IN  UINTN                 Size,
-  IN  UINT32                VolumeId,
-  IN  CHAR16                *FilePath
-  )
-{
-  VS_DEV                    *Dev;
-  EFI_STATUS                Status;
-  EFI_EVENT                 Event;
-
-  Status = gBS->AllocatePool (EfiRuntimeServicesData, sizeof(VS_DEV), (VOID **) &Dev);
-  ASSERT_EFI_ERROR (Status);
-  ZeroMem (Dev, sizeof(VS_DEV));
-
-  Dev->Signature          = VS_DEV_SIGNATURE;
-  Dev->Size               = Size;
-  VAR_DATA_PTR (Dev)      = (UINT8 *) (UINTN) NvStorageBase;
-  VAR_FILE_VOLUMEID (Dev) = VolumeId;
-  StrCpy (VAR_FILE_FILEPATH (Dev), FilePath);
-  Dev->VarStore.Erase     = FileEraseStore;
-  Dev->VarStore.Write     = FileWriteStore;
-
-  DEBUG ((EFI_D_ERROR, "FileStorageConstructor(0x%0x:0x%0x): added!\n", NvStorageBase, Size));
-
-  // add notify on SFS's installation.
-
-  Status = gBS->CreateEvent (
-                  EVT_NOTIFY_SIGNAL,
-                  TPL_CALLBACK,
-                  OnSimpleFileSystemInstall,
-                  Dev,
-                  &Event
-                  );
-  ASSERT_EFI_ERROR (Status);
-
-  Status = gBS->RegisterProtocolNotify (
-                  &gEfiSimpleFileSystemProtocolGuid,
-                  Event,
-                  &mSFSRegistration
-                  );
-  ASSERT_EFI_ERROR (Status);
-
-  *VarStore       = &Dev->VarStore;
-  *GoVirtualEvent = OnVirtualAddressChangeFs;
-  return EFI_SUCCESS;
-}
-
-EFI_STATUS
-EFIAPI
-FileEraseStore(
-  IN VARIABLE_STORAGE   *This
-  )
-{
-  EFI_STATUS              Status;
-  VS_DEV                  *Dev;
-  EFI_FILE_PROTOCOL       *File;
-  UINTN                   NumBytes;
-
-  Status = EFI_SUCCESS;
-  Dev    = DEV_FROM_THIS(This);
-
-  SetMem (VAR_DATA_PTR (Dev), Dev->Size, VAR_DEFAULT_VALUE);
-
-  if (!EfiAtRuntime () && VAR_FILE_DEVICEPATH (Dev) != NULL) {
-    Status = OpenStore (
-               VAR_FILE_DEVICEPATH (Dev), 
-               VAR_FILE_FILEPATH (Dev), 
-               EFI_FILE_MODE_WRITE | EFI_FILE_MODE_READ,
-               &File
-               );
-    ASSERT_EFI_ERROR (Status);
-    NumBytes = Dev->Size;
-    Status = File->Write (File, &NumBytes, VAR_DATA_PTR (Dev));
-    ASSERT_EFI_ERROR (Status);
-    FileClose (File);
-  }
-  
-  return Status;
-}
-
-EFI_STATUS
-EFIAPI
-FileWriteStore (
-  IN VARIABLE_STORAGE     *This,
-  IN UINTN                Offset,
-  IN UINTN                BufferSize,
-  IN VOID                 *Buffer
-  )
-{
-  EFI_STATUS              Status;
-  VS_DEV                  *Dev;
-  EFI_FILE_PROTOCOL       *File;
-
-  Status = EFI_SUCCESS;
-  Dev    = DEV_FROM_THIS(This);
-
-  ASSERT (Buffer != NULL);
-  ASSERT (Offset + BufferSize <= Dev->Size);
-
-  CopyMem (VAR_DATA_PTR (Dev) + Offset, Buffer, BufferSize);
-  
-  if (!EfiAtRuntime () && VAR_FILE_DEVICEPATH (Dev) != NULL) {
-    Status = OpenStore (
-               VAR_FILE_DEVICEPATH (Dev), 
-               VAR_FILE_FILEPATH (Dev), 
-               EFI_FILE_MODE_WRITE | EFI_FILE_MODE_READ,
-               &File
-               );
-    Status = File->SetPosition (File, Offset);
-    ASSERT_EFI_ERROR (Status);
-    Status = File->Write (File, &BufferSize, Buffer);
-    ASSERT_EFI_ERROR (Status);
-    FileClose (File);
-  }
-  return Status;
-}
-
-VOID
-EFIAPI
-OnVirtualAddressChangeFs (
-  IN EFI_EVENT            Event,
-  IN VOID                 *Context
-  )
-{
-  VS_DEV  *Dev;
-
-  Dev = DEV_FROM_THIS (Context);
-
-  EfiConvertPointer (0, (VOID **) &VAR_DATA_PTR (Dev));
-  EfiConvertPointer (0, (VOID **) &Dev->VarStore.Erase);
-  EfiConvertPointer (0, (VOID **) &Dev->VarStore.Write);
-}
-
-EFI_STATUS
-OpenStore (
-  IN  EFI_DEVICE_PATH_PROTOCOL  *Device,
-  IN  CHAR16                    *FilePathName,
-  IN  UINT64                    OpenMode,
-  OUT EFI_FILE_PROTOCOL         **File
-  )
-{
-  EFI_HANDLE                        Handle;
-  EFI_FILE_HANDLE                   Root;
-  EFI_SIMPLE_FILE_SYSTEM_PROTOCOL   *Volume;
-  EFI_STATUS                        Status;
-
-  *File = NULL;
-
-  Status = gBS->LocateDevicePath (
-                  &gEfiSimpleFileSystemProtocolGuid,
-                  &Device, 
-                  &Handle
-                  );
-
-  if (EFI_ERROR (Status)) {
-    return Status;
-  }
-
-  Status = gBS->HandleProtocol (
-                  Handle,
-                  &gEfiSimpleFileSystemProtocolGuid,
-                  (VOID **) &Volume
-                  );
-  if (EFI_ERROR (Status)) {
-    return Status;
-  }
-
-  //
-  // Open the root directory of the volume
-  //
-  Root = NULL;
-  Status = Volume->OpenVolume (
-                     Volume,
-                     &Root
-                     );
-  ASSERT_EFI_ERROR (Status);
-  ASSERT (Root != NULL);
-
-  //
-  // Open file
-  //
-  Status = Root->Open (
-                   Root,
-                   File,
-                   FilePathName,
-                   OpenMode,
-                   0
-                   );
-  if (EFI_ERROR (Status)) {
-    *File = NULL;
-  }
-
-  //
-  // Close the Root directory
-  //
-  Root->Close (Root);
-  return Status;
-}
Index: DuetPkg/FSVariable/MemStorage.c
===================================================================
--- DuetPkg/FSVariable/MemStorage.c	(revision 1)
+++ DuetPkg/FSVariable/MemStorage.c	(working copy)
@@ -1,129 +0,0 @@
-/*++
-
-Copyright (c) 2006 - 2007, Intel Corporation. All rights reserved.<BR>
-This program and the accompanying materials
-are licensed and made available under the terms and conditions of the BSD License
-which accompanies this distribution.  The full text of the license may be found at
-http://opensource.org/licenses/bsd-license.php
-
-THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-Module Name:
-
-    MemStorage.c
-
-Abstract:
-
-    handles variable store/reads with emulated memory
-
-Revision History
-
---*/
-#include "FSVariable.h"
-
-VOID
-EFIAPI
-OnVirtualAddressChangeMs (
-  IN EFI_EVENT            Event,
-  IN VOID                 *Context
-  );
-
-EFI_STATUS
-EFIAPI
-MemEraseStore(
-  IN VARIABLE_STORAGE   *This
-  );
-
-EFI_STATUS
-EFIAPI
-MemWriteStore (
-  IN VARIABLE_STORAGE   *This,
-  IN UINTN                Offset,
-  IN UINTN                BufferSize,
-  IN VOID                 *Buffer
-  );
-
-EFI_STATUS
-MemStorageConstructor (
-  OUT VARIABLE_STORAGE          **VarStore,
-  OUT EFI_EVENT_NOTIFY          *GoVirtualEvent,
-  IN  UINTN                     Size
-  )
-{
-  EFI_STATUS                  Status;
-  VS_DEV                      *Dev;
-
-  Status = gBS->AllocatePool (EfiRuntimeServicesData, sizeof(VS_DEV), (VOID **) &Dev);
-  ASSERT_EFI_ERROR (Status);
-
-  ZeroMem (Dev, sizeof(VS_DEV));
-
-  Dev->Signature   = VS_DEV_SIGNATURE;
-  Dev->Size        = Size;
-
-  Dev->VarStore.Erase    = MemEraseStore;
-  Dev->VarStore.Write    = MemWriteStore;
-
-  Status = gBS->AllocatePool (EfiRuntimeServicesData, Size, (VOID **) &VAR_DATA_PTR (Dev));
-  ASSERT_EFI_ERROR (Status);
-
-  DEBUG ((EFI_D_ERROR, "VStorage: Size = 0x%x\n", Size));
-  
-  *VarStore       = &Dev->VarStore;
-  *GoVirtualEvent = OnVirtualAddressChangeMs;
-
-  return EFI_SUCCESS;
-}
-
-VOID
-EFIAPI
-OnVirtualAddressChangeMs (
-  IN EFI_EVENT            Event,
-  IN VOID                 *Context
-  )
-{
-  VS_DEV                  *Dev;
-
-  Dev = DEV_FROM_THIS (Context);
-
-  EfiConvertPointer (0, (VOID **)&VAR_DATA_PTR (Dev));
-  EfiConvertPointer (0, (VOID **)&Dev->VarStore.Erase);
-  EfiConvertPointer (0, (VOID **)&Dev->VarStore.Write);
-}
-
-EFI_STATUS
-EFIAPI
-MemEraseStore(
-  IN VARIABLE_STORAGE   *This
-  )
-{
-  VS_DEV              *Dev;
-
-  Dev = DEV_FROM_THIS(This);
-  SetMem (VAR_DATA_PTR (Dev), Dev->Size, VAR_DEFAULT_VALUE);
-  return EFI_SUCCESS;
-}
-
-
-EFI_STATUS
-EFIAPI
-MemWriteStore (
-  IN VARIABLE_STORAGE     *This,
-  IN UINTN                Offset,
-  IN UINTN                BufferSize,
-  IN VOID                 *UserBuffer
-  )
-{
-  VS_DEV              *Dev;
-
-  Dev = DEV_FROM_THIS(This);
-
-  ASSERT (Offset + BufferSize < Dev->Size);
-
-  // For better performance
-  if (VAR_DATA_PTR (Dev) + Offset != UserBuffer) {
-    CopyMem (VAR_DATA_PTR (Dev) + Offset, UserBuffer, BufferSize);
-  }
-  return EFI_SUCCESS;
-}
Index: DuetPkg/FSVariable/VariableStorage.h
===================================================================
--- DuetPkg/FSVariable/VariableStorage.h	(revision 1)
+++ DuetPkg/FSVariable/VariableStorage.h	(working copy)
@@ -1,112 +0,0 @@
-/*++
-
-Copyright (c) 2006 - 2007, Intel Corporation. All rights reserved.<BR>
-This program and the accompanying materials                          
-are licensed and made available under the terms and conditions of the BSD License         
-which accompanies this distribution.  The full text of the license may be found at        
-http://opensource.org/licenses/bsd-license.php                                            
-                                                                                          
-THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,                     
-WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.             
-
-Module Name:
-
-    VariableStorage.h
-
-Abstract:
-
-    handles variable store/reads with memory and file
-
-Revision History
-
---*/
-#ifndef _VARIABLE_STORAGE_H_
-#define _VARIABLE_STORAGE_H_
-
-#define VAR_DEFAULT_VALUE           (0xff)
-#define VAR_DEFAULT_VALUE_16        SIGNATURE_16 (VAR_DEFAULT_VALUE, VAR_DEFAULT_VALUE)
-#define VAR_DEFAULT_VALUE_32        SIGNATURE_32 (VAR_DEFAULT_VALUE, VAR_DEFAULT_VALUE, \
-                                                      VAR_DEFAULT_VALUE, VAR_DEFAULT_VALUE)
-
-typedef struct _VARIABLE_STORAGE VARIABLE_STORAGE;
-
-EFI_STATUS
-FileStorageConstructor (
-  OUT VARIABLE_STORAGE      **VarStore,
-  OUT EFI_EVENT_NOTIFY      *GoVirtualEvent,
-  IN  EFI_PHYSICAL_ADDRESS  NvStorageBase,
-  IN  UINTN                 Size,
-  IN  UINT32                VolumeId,
-  IN  CHAR16                *FilePath
-  );
-
-EFI_STATUS
-MemStorageConstructor (
-  OUT VARIABLE_STORAGE          **VarStore,
-  OUT EFI_EVENT_NOTIFY          *GoVirtualEvent,
-  IN  UINTN                     Size
-  );
-
-typedef
-EFI_STATUS
-(EFIAPI *ERASE_STORE) (
-  IN VARIABLE_STORAGE   *This
-  );
-
-typedef
-EFI_STATUS
-(EFIAPI *WRITE_STORE) (
-  IN VARIABLE_STORAGE   *This,
-  IN UINTN              Offset,
-  IN UINTN              BufferSize,
-  IN VOID               *Buffer
-  );
-
-struct _VARIABLE_STORAGE {
-
-  //
-  // Functions to access the storage
-  //
-  ERASE_STORE           Erase;
-  WRITE_STORE           Write;
-};
-
-typedef struct _VS_FILE_INFO {
-  UINT8                     *FileData;      // local buffer for reading acceleration
-
-  EFI_DEVICE_PATH_PROTOCOL  *DevicePath;    // device having storage file
-  UINT32                    VolumeId;
-  CHAR16                    FilePath[256];
-} VS_FILE_INFO;
-
-typedef struct _VS_MEM_INFO {
-  UINT8                     *MemData;
-} VS_MEM_INFO;
-
-typedef struct _VS_DEV {
-  UINT32             Signature;
-  VARIABLE_STORAGE   VarStore;
-  UINTN              Size;
-  
-  union {
-    //
-    // finally visit FileInfo.FileData or MemInfo.MemData
-    //
-    UINT8            *Data;
-    
-    VS_FILE_INFO     FileInfo;
-    VS_MEM_INFO      MemInfo;
-  } Info;
-
-} VS_DEV;
-
-#define VS_DEV_SIGNATURE        SIGNATURE_32 ('$', 'V', 'S', 'D')
-#define DEV_FROM_THIS(a)        CR (a, VS_DEV, VarStore, VS_DEV_SIGNATURE)
-
-#define VAR_DATA_PTR(a)         ((a)->Info.Data)
-#define VAR_FILE_DEVICEPATH(a)  ((a)->Info.FileInfo.DevicePath)
-#define VAR_FILE_VOLUMEID(a)    ((a)->Info.FileInfo.VolumeId)
-#define VAR_FILE_FILEPATH(a)    ((a)->Info.FileInfo.FilePath)
-
-
-#endif
Index: DuetPkg/FvbRuntimeService/DUETFwh.inf
===================================================================
--- DuetPkg/FvbRuntimeService/DUETFwh.inf	(revision 1)
+++ DuetPkg/FvbRuntimeService/DUETFwh.inf	(working copy)
@@ -1,58 +0,0 @@
-## @file
-#
-# Copyright (c) 2007 - 2010, Intel Corporation. All rights reserved.<BR>
-# This program and the accompanying materials                          
-# are licensed and made available under the terms and conditions of the BSD License         
-# which accompanies this distribution.  The full text of the license may be found at        
-# http://opensource.org/licenses/bsd-license.php                                            
-#                                                                                           
-# THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,                     
-# WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.             
-# 
-#  Module Name:
-#
-#   DUETFwh.inf
-#
-#  Abstract:
-#
-#    Component description file for DUET Module
-#
-##
-
-[Defines]
-  INF_VERSION                    = 0x00010005
-  BASE_NAME                      = DuetFwh
-  FILE_GUID                      = 46E3256A-E5C1-4d2a-8282-505AFB41CE65
-  MODULE_TYPE                    = DXE_RUNTIME_DRIVER
-  VERSION_STRING                 = 1.0
-  ENTRY_POINT                    = FvbInitialize
-
-[Packages]
-  MdePkg/MdePkg.dec
-  MdeModulePkg/MdeModulePkg.dec
-  DuetPkg/DuetPkg.dec
-
-[Sources]
-  FWBlockService.c
-  FwBlockService.h
-  FvbInfo.c
-  FileIo.c
-  FileIo.h
-
-[LibraryClasses]
-  DevicePathLib
-  UefiLib
-  UefiDriverEntryPoint
-  UefiRuntimeLib
-  HobLib
-
-[Guids]
-  gEfiFlashMapHobGuid
-
-[Protocols]
-  gEfiSimpleFileSystemProtocolGuid
-  gEfiFirmwareVolumeBlockProtocolGuid
-  gEfiBlockIoProtocolGuid
-
-[Depex]
-  TRUE
Index: DuetPkg/FvbRuntimeService/FWBlockService.c
===================================================================
--- DuetPkg/FvbRuntimeService/FWBlockService.c	(revision 1)
+++ DuetPkg/FvbRuntimeService/FWBlockService.c	(working copy)
@@ -1,1659 +0,0 @@
-/**@file
-Copyright (c) 2007 - 2009, Intel Corporation. All rights reserved.<BR>
-This program and the accompanying materials                          
-are licensed and made available under the terms and conditions of the BSD License         
-which accompanies this distribution.  The full text of the license may be found at        
-http://opensource.org/licenses/bsd-license.php                                            
-                                                                                          
-THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,                     
-WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.             
-
-Module Name:
-
-  FWBlockService.c
-    
-Abstract:
-
-Revision History
-
-**/
-#include "FWBlockService.h"
-#include "EfiFlashMap.h"
-#include "FileIo.h"
-#include "FlashLayout.h"
-
-ESAL_FWB_GLOBAL       *mFvbModuleGlobal;
-VOID                  *mSFSRegistration;
-#define TRY_ASSIGN(var, value)  if(var != NULL) {*var = value;}
-
-EFI_FW_VOL_BLOCK_DEVICE mFvbDeviceTemplate = {
-  FVB_DEVICE_SIGNATURE,
-  {
-    {
-      {
-        HARDWARE_DEVICE_PATH,
-        HW_MEMMAP_DP,
-        {
-          sizeof (MEMMAP_DEVICE_PATH),
-          0
-        }
-      },
-      EfiMemoryMappedIO,
-      0,
-      0,
-    },
-    {
-      END_DEVICE_PATH_TYPE,
-      END_ENTIRE_DEVICE_PATH_SUBTYPE,
-      {
-        sizeof (EFI_DEVICE_PATH_PROTOCOL),
-        0
-      }
-    }
-  },
-  0,
-  {
-    FvbProtocolGetAttributes,
-    FvbProtocolSetAttributes,
-    FvbProtocolGetPhysicalAddress,
-    FvbProtocolGetBlockSize,
-    FvbProtocolRead,
-    FvbProtocolWrite,
-    FvbProtocolEraseBlocks,
-    NULL
-  }
-};
-
-
-EFI_STATUS
-FlashFdWrite (
-  IN     UINTN                            Address,
-  IN     EFI_FW_VOL_INSTANCE              *FwhInstance,
-  IN OUT UINTN                            *NumBytes,
-  IN     UINT8                            *Buffer
-  )
-/*++
-
-Routine Description:
-  Writes specified number of bytes from the input buffer to the address
-
-Arguments:
-
-Returns: 
-
---*/
-{
-  EFI_STATUS          Status;
-  EFI_FILE_PROTOCOL   *File;
-  UINTN               FileOffset;
-  UINTN               BufferForFile;
-  UINTN               Length;
-
-  Status = EFI_SUCCESS;
-  CopyMem ((VOID *) Address, Buffer, *NumBytes);
-
-  if (!EfiAtRuntime () && (FwhInstance->Device != NULL)) {
-    Status = FileOpen (FwhInstance->Device, FwhInstance->MappedFile, &File, EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE);
-    ASSERT_EFI_ERROR (Status);
-    if (!EFI_ERROR (Status)) {
-      if (Address - FwhInstance->FvBase[FVB_PHYSICAL] < FwhInstance->Offset) {
-        FileOffset = 0;
-        BufferForFile = FwhInstance->FvBase[FVB_PHYSICAL] + FwhInstance->Offset;
-        Length = *NumBytes - (FwhInstance->Offset - (Address - FwhInstance->FvBase[FVB_PHYSICAL]));
-      } else {
-        FileOffset = Address - FwhInstance->FvBase[FVB_PHYSICAL] - FwhInstance->Offset;
-        BufferForFile = Address;
-        Length = *NumBytes;
-      }
-      
-      Status = FileWrite (File, FileOffset, BufferForFile, Length);
-      ASSERT_EFI_ERROR (Status);
-      FileClose (File);
-    }
-  }
-  return Status;
-}
-
-EFI_STATUS
-FlashFdErase (
-  IN UINTN                                Address,
-  IN EFI_FW_VOL_INSTANCE                  *FwhInstance,
-  IN UINTN                                LbaLength
-  )
-/*++
-
-Routine Description:
-  Erase a certain block from address LbaWriteAddress
-
-Arguments:
-
-Returns: 
-
---*/
-{
-  EFI_STATUS           Status;
-  EFI_FILE_PROTOCOL    *File;
-  UINTN                FileOffset;
-  UINTN                BufferForFile;
-  UINTN                Length;
-
-  Status = EFI_SUCCESS;
-
-  SetMem ((VOID *)Address, LbaLength, 0xff);
-
-  if (!EfiAtRuntime () && (FwhInstance->Device != NULL)) {
-    Status = FileOpen (FwhInstance->Device, FwhInstance->MappedFile, &File, EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE);
-    ASSERT_EFI_ERROR (Status);
-    if (!EFI_ERROR (Status)) {
-      if (Address - FwhInstance->FvBase[FVB_PHYSICAL] < FwhInstance->Offset) {
-        FileOffset = 0;
-        BufferForFile = FwhInstance->FvBase[FVB_PHYSICAL] + FwhInstance->Offset;
-        Length = LbaLength - (FwhInstance->Offset - (Address - FwhInstance->FvBase[FVB_PHYSICAL]));
-      } else {
-        FileOffset = Address - FwhInstance->FvBase[FVB_PHYSICAL] - FwhInstance->Offset;
-        BufferForFile = Address;
-        Length = LbaLength;
-      }
-      
-      Status = FileWrite (File, FileOffset, BufferForFile, Length);
-      ASSERT_EFI_ERROR (Status);
-      FileClose (File);
-    }
-  }
-  return Status;
-}
-
-VOID
-EFIAPI
-FvbVirtualddressChangeEvent (
-  IN EFI_EVENT        Event,
-  IN VOID             *Context
-  )
-/*++
-
-Routine Description:
-
-  Fixup internal data so that EFI and SAL can be call in virtual mode.
-  Call the passed in Child Notify event and convert the mFvbModuleGlobal
-  date items to there virtual address.
-
-  mFvbModuleGlobal->FvInstance[FVB_PHYSICAL]  - Physical copy of instance data
-  mFvbModuleGlobal->FvInstance[FVB_VIRTUAL]   - Virtual pointer to common 
-                                                instance data.
-
-Arguments:
-
-  (Standard EFI notify event - EFI_EVENT_NOTIFY)
-
-Returns: 
-
-  None
-
---*/
-{
-  EFI_FW_VOL_INSTANCE *FwhInstance;
-  UINTN               Index;
-
-  EfiConvertPointer (0, (VOID **) &mFvbModuleGlobal->FvInstance[FVB_VIRTUAL]);
-
-  //
-  // Convert the base address of all the instances
-  //
-  Index       = 0;
-  FwhInstance = mFvbModuleGlobal->FvInstance[FVB_PHYSICAL];
-  while (Index < mFvbModuleGlobal->NumFv) {
-    EfiConvertPointer (0, (VOID **) &FwhInstance->FvBase[FVB_VIRTUAL]);
-    FwhInstance = (EFI_FW_VOL_INSTANCE *) ((UINTN)((UINT8 *)FwhInstance) + FwhInstance->VolumeHeader.HeaderLength
-                    + (sizeof (EFI_FW_VOL_INSTANCE) - sizeof (EFI_FIRMWARE_VOLUME_HEADER)));
-    Index++;
-  }
-
-  EfiConvertPointer (0, (VOID **) &mFvbModuleGlobal->FvbScratchSpace[FVB_VIRTUAL]);
-  EfiConvertPointer (0, (VOID **) &mFvbModuleGlobal);
-}
-
-EFI_STATUS
-GetFvbInstance (
-  IN  UINTN                               Instance,
-  IN  ESAL_FWB_GLOBAL                     *Global,
-  OUT EFI_FW_VOL_INSTANCE                 **FwhInstance,
-  IN BOOLEAN                              Virtual
-  )
-/*++
-
-Routine Description:
-  Retrieves the physical address of a memory mapped FV
-
-Arguments:
-  Instance              - The FV instance whose base address is going to be
-                          returned
-  Global                - Pointer to ESAL_FWB_GLOBAL that contains all
-                          instance data
-  FwhInstance           - The EFI_FW_VOL_INSTANCE fimrware instance structure
-  Virtual               - Whether CPU is in virtual or physical mode
-
-Returns: 
-  EFI_SUCCESS           - Successfully returns
-  EFI_INVALID_PARAMETER - Instance not found
-
---*/
-{
-  EFI_FW_VOL_INSTANCE *FwhRecord;
-
-  if (Instance >= Global->NumFv) {
-    return EFI_INVALID_PARAMETER;
-  }
-  //
-  // Find the right instance of the FVB private data
-  //
-  FwhRecord = Global->FvInstance[Virtual];
-  while (Instance > 0) {
-    FwhRecord = (EFI_FW_VOL_INSTANCE *) ((UINTN)((UINT8 *)FwhRecord) + FwhRecord->VolumeHeader.HeaderLength 
-                     + (sizeof (EFI_FW_VOL_INSTANCE) - sizeof (EFI_FIRMWARE_VOLUME_HEADER)));
-    Instance--;
-  }
-
-  *FwhInstance = FwhRecord;
-
-  return EFI_SUCCESS;
-}
-
-EFI_STATUS
-FvbGetPhysicalAddress (
-  IN UINTN                                Instance,
-  OUT EFI_PHYSICAL_ADDRESS                *Address,
-  IN ESAL_FWB_GLOBAL                      *Global,
-  IN BOOLEAN                              Virtual
-  )
-/*++
-
-Routine Description:
-  Retrieves the physical address of a memory mapped FV
-
-Arguments:
-  Instance              - The FV instance whose base address is going to be
-                          returned
-  Address               - Pointer to a caller allocated EFI_PHYSICAL_ADDRESS 
-                          that on successful return, contains the base address
-                          of the firmware volume. 
-  Global                - Pointer to ESAL_FWB_GLOBAL that contains all
-                          instance data
-  Virtual               - Whether CPU is in virtual or physical mode
-
-Returns: 
-  EFI_SUCCESS           - Successfully returns
-  EFI_INVALID_PARAMETER - Instance not found
-
---*/
-{
-  EFI_FW_VOL_INSTANCE *FwhInstance;
-  EFI_STATUS          Status;
-
-  //
-  // Find the right instance of the FVB private data
-  //
-  Status = GetFvbInstance (Instance, Global, &FwhInstance, Virtual);
-  ASSERT_EFI_ERROR (Status);
-  *Address = FwhInstance->FvBase[Virtual];
-
-  return EFI_SUCCESS;
-}
-
-EFI_STATUS
-FvbGetVolumeAttributes (
-  IN UINTN                                Instance,
-  OUT EFI_FVB_ATTRIBUTES_2                *Attributes,
-  IN ESAL_FWB_GLOBAL                      *Global,
-  IN BOOLEAN                              Virtual
-  )
-/*++
-
-Routine Description:
-  Retrieves attributes, insures positive polarity of attribute bits, returns
-  resulting attributes in output parameter
-
-Arguments:
-  Instance              - The FV instance whose attributes is going to be 
-                          returned
-  Attributes            - Output buffer which contains attributes
-  Global                - Pointer to ESAL_FWB_GLOBAL that contains all
-                          instance data
-  Virtual               - Whether CPU is in virtual or physical mode
-
-Returns: 
-  EFI_SUCCESS           - Successfully returns
-  EFI_INVALID_PARAMETER - Instance not found
-
---*/
-{
-  EFI_FW_VOL_INSTANCE *FwhInstance;
-  EFI_STATUS          Status;
-
-  //
-  // Find the right instance of the FVB private data
-  //
-  Status = GetFvbInstance (Instance, Global, &FwhInstance, Virtual);
-  ASSERT_EFI_ERROR (Status);
-  *Attributes = FwhInstance->VolumeHeader.Attributes;
-
-  return EFI_SUCCESS;
-}
-
-EFI_STATUS
-FvbGetLbaAddress (
-  IN  UINTN                               Instance,
-  IN  EFI_LBA                             Lba,
-  OUT UINTN                               *LbaAddress  OPTIONAL,
-  OUT UINTN                               *LbaLength   OPTIONAL,
-  OUT UINTN                               *NumOfBlocks OPTIONAL,
-  IN  ESAL_FWB_GLOBAL                     *Global,
-  IN  BOOLEAN                             Virtual
-  )
-/*++
-
-Routine Description:
-  Retrieves the starting address of an LBA in an FV
-
-Arguments:
-  Instance              - The FV instance which the Lba belongs to
-  Lba                   - The logical block address
-  LbaAddress            - On output, contains the physical starting address
-                          of the Lba for writing
-  LbaLength             - On output, contains the length of the block
-  NumOfBlocks           - A pointer to a caller allocated UINTN in which the
-                          number of consecutive blocks starting with Lba is
-                          returned. All blocks in this range have a size of
-                          BlockSize
-  Global                - Pointer to ESAL_FWB_GLOBAL that contains all
-                          instance data
-  Virtual               - Whether CPU is in virtual or physical mode
-
-Returns: 
-  EFI_SUCCESS           - Successfully returns
-  EFI_INVALID_PARAMETER - Instance not found
-
---*/
-{
-  UINT32                  NumBlocks;
-  UINT32                  BlockLength;
-  UINTN                   Offset;
-  EFI_LBA                 StartLba;
-  EFI_LBA                 NextLba;
-  EFI_FW_VOL_INSTANCE     *FwhInstance;
-  EFI_FV_BLOCK_MAP_ENTRY  *BlockMap;
-  EFI_STATUS              Status;
-
-  //
-  // Find the right instance of the FVB private data
-  //
-  Status = GetFvbInstance (Instance, Global, &FwhInstance, Virtual);
-  ASSERT_EFI_ERROR (Status);
-
-  StartLba  = 0;
-  Offset    = 0;
-  BlockMap  = &(FwhInstance->VolumeHeader.BlockMap[0]);
-
-  //
-  // Parse the blockmap of the FV to find which map entry the Lba belongs to
-  //
-  while (TRUE) {
-    NumBlocks   = BlockMap->NumBlocks;
-    BlockLength = BlockMap->Length;
-
-    if (NumBlocks == 0 || BlockLength == 0) {
-      return EFI_INVALID_PARAMETER;
-    }
-
-    NextLba = StartLba + NumBlocks;
-
-    //
-    // The map entry found
-    //
-    if (Lba >= StartLba && Lba < NextLba) {
-      Offset = Offset + (UINTN) MultU64x32 ((Lba - StartLba), BlockLength);
-
-      if (LbaAddress) {
-        *LbaAddress = FwhInstance->FvBase[Virtual] + Offset;
-      }
-
-      if (LbaLength) {
-        *LbaLength = BlockLength;
-      }
-
-      if (NumOfBlocks) {
-        *NumOfBlocks = (UINTN) (NextLba - Lba);
-      }
-
-      return EFI_SUCCESS;
-    }
-
-    StartLba  = NextLba;
-    Offset    = Offset + NumBlocks * BlockLength;
-    BlockMap++;
-  }
-}
-
-EFI_STATUS
-FvbReadBlock (
-  IN UINTN                                Instance,
-  IN EFI_LBA                              Lba,
-  IN UINTN                                BlockOffset,
-  IN OUT UINTN                            *NumBytes,
-  IN UINT8                                *Buffer,
-  IN ESAL_FWB_GLOBAL                      *Global,
-  IN BOOLEAN                              Virtual
-  )
-/*++
-
-Routine Description:
-  Reads specified number of bytes into a buffer from the specified block
-
-Arguments:
-  Instance              - The FV instance to be read from
-  Lba                   - The logical block address to be read from
-  BlockOffset           - Offset into the block at which to begin reading
-  NumBytes              - Pointer that on input contains the total size of
-                          the buffer. On output, it contains the total number
-                          of bytes read
-  Buffer                - Pointer to a caller allocated buffer that will be
-                          used to hold the data read
-  Global                - Pointer to ESAL_FWB_GLOBAL that contains all
-                          instance data
-  Virtual               - Whether CPU is in virtual or physical mode
-
-Returns: 
-  EFI_SUCCESS           - The firmware volume was read successfully and 
-                          contents are in Buffer
-  EFI_BAD_BUFFER_SIZE   - Read attempted across a LBA boundary. On output,
-                          NumBytes contains the total number of bytes returned
-                          in Buffer
-  EFI_ACCESS_DENIED     - The firmware volume is in the ReadDisabled state
-  EFI_DEVICE_ERROR      - The block device is not functioning correctly and 
-                          could not be read
-  EFI_INVALID_PARAMETER - Instance not found, or NumBytes, Buffer are NULL
-
---*/
-{
-  EFI_FVB_ATTRIBUTES_2  Attributes;
-  UINTN                 LbaAddress;
-  UINTN                 LbaLength;
-  EFI_STATUS            Status;
-
-  //
-  // Check for invalid conditions
-  //
-  if ((NumBytes == NULL) || (Buffer == NULL)) {
-    return EFI_INVALID_PARAMETER;
-  }
-
-  if (*NumBytes == 0) {
-    return EFI_INVALID_PARAMETER;
-  }
-
-  Status = FvbGetLbaAddress (Instance, Lba, &LbaAddress, &LbaLength, NULL, Global, Virtual);
-  if (EFI_ERROR (Status)) {
-    return Status;
-  }
-  //
-  // Check if the FV is read enabled
-  //
-  FvbGetVolumeAttributes (Instance, &Attributes, Global, Virtual);
-
-  if ((Attributes & EFI_FVB2_READ_STATUS) == 0) {
-    return EFI_ACCESS_DENIED;
-  }
-  //
-  // Perform boundary checks and adjust NumBytes
-  //
-  if (BlockOffset > LbaLength) {
-    return EFI_INVALID_PARAMETER;
-  }
-
-  if (LbaLength < (*NumBytes + BlockOffset)) {
-    *NumBytes = (UINT32) (LbaLength - BlockOffset);
-    Status    = EFI_BAD_BUFFER_SIZE;
-  }
-
-  CopyMem (Buffer, (VOID *) (LbaAddress + BlockOffset), (UINTN) *NumBytes);
-
-  return Status;
-}
-EFI_STATUS
-FvbWriteBlock (
-  IN UINTN                                Instance,
-  IN EFI_LBA                              Lba,
-  IN UINTN                                BlockOffset,
-  IN OUT UINTN                            *NumBytes,
-  IN UINT8                                *Buffer,
-  IN ESAL_FWB_GLOBAL                      *Global,
-  IN BOOLEAN                              Virtual
-  )
-/*++
-
-Routine Description:
-  Writes specified number of bytes from the input buffer to the block
-
-Arguments:
-  Instance              - The FV instance to be written to
-  Lba                   - The starting logical block index to write to
-  BlockOffset           - Offset into the block at which to begin writing
-  NumBytes              - Pointer that on input contains the total size of
-                          the buffer. On output, it contains the total number
-                          of bytes actually written
-  Buffer                - Pointer to a caller allocated buffer that contains
-                          the source for the write
-  Global                - Pointer to ESAL_FWB_GLOBAL that contains all
-                          instance data
-  Virtual               - Whether CPU is in virtual or physical mode
-
-Returns: 
-  EFI_SUCCESS           - The firmware volume was written successfully
-  EFI_BAD_BUFFER_SIZE   - Write attempted across a LBA boundary. On output,
-                          NumBytes contains the total number of bytes
-                          actually written
-  EFI_ACCESS_DENIED     - The firmware volume is in the WriteDisabled state
-  EFI_DEVICE_ERROR      - The block device is not functioning correctly and 
-                          could not be written
-  EFI_INVALID_PARAMETER - Instance not found, or NumBytes, Buffer are NULL
-
---*/
-{
-  EFI_FVB_ATTRIBUTES_2  Attributes;
-  UINTN                 LbaAddress;
-  UINTN                 LbaLength;
-  EFI_FW_VOL_INSTANCE   *FwhInstance;
-  EFI_STATUS            Status;
-  EFI_STATUS            ReturnStatus;
-
-  //
-  // Find the right instance of the FVB private data
-  //
-  Status = GetFvbInstance (Instance, Global, &FwhInstance, Virtual);
-  ASSERT_EFI_ERROR (Status);
-
-  //
-  // Writes are enabled in the init routine itself
-  //
-  if (!FwhInstance->WriteEnabled) {
-    return EFI_ACCESS_DENIED;
-  }
-  //
-  // Check for invalid conditions
-  //
-  if ((NumBytes == NULL) || (Buffer == NULL)) {
-    return EFI_INVALID_PARAMETER;
-  }
-
-  if (*NumBytes == 0) {
-    return EFI_INVALID_PARAMETER;
-  }
-
-  Status = FvbGetLbaAddress (Instance, Lba, &LbaAddress, &LbaLength, NULL, Global, Virtual);
-  if (EFI_ERROR (Status)) {
-    return Status;
-  }
-  //
-  // Check if the FV is write enabled
-  //
-  FvbGetVolumeAttributes (Instance, &Attributes, Global, Virtual);
-
-  if ((Attributes & EFI_FVB2_WRITE_STATUS) == 0) {
-    return EFI_ACCESS_DENIED;
-  }
-  //
-  // Perform boundary checks and adjust NumBytes
-  //
-  if (BlockOffset > LbaLength) {
-    return EFI_INVALID_PARAMETER;
-  }
-
-  if (LbaLength < (*NumBytes + BlockOffset)) {
-    *NumBytes = (UINT32) (LbaLength - BlockOffset);
-    Status    = EFI_BAD_BUFFER_SIZE;
-  }
-
-  ReturnStatus = FlashFdWrite (
-                  LbaAddress + BlockOffset,
-                  FwhInstance,
-                  NumBytes,
-                  Buffer
-                  );
-  if (EFI_ERROR (ReturnStatus)) {
-    return ReturnStatus;
-  }
-
-  return Status;
-}
-
-EFI_STATUS
-FvbEraseBlock (
-  IN UINTN                                Instance,
-  IN EFI_LBA                              Lba,
-  IN ESAL_FWB_GLOBAL                      *Global,
-  IN BOOLEAN                              Virtual
-  )
-/*++
-
-Routine Description:
-  Erases and initializes a firmware volume block
-
-Arguments:
-  Instance              - The FV instance to be erased
-  Lba                   - The logical block index to be erased
-  Global                - Pointer to ESAL_FWB_GLOBAL that contains all
-                          instance data
-  Virtual               - Whether CPU is in virtual or physical mode
-
-Returns: 
-  EFI_SUCCESS           - The erase request was successfully completed
-  EFI_ACCESS_DENIED     - The firmware volume is in the WriteDisabled state
-  EFI_DEVICE_ERROR      - The block device is not functioning correctly and 
-                          could not be written. Firmware device may have been
-                          partially erased
-  EFI_INVALID_PARAMETER - Instance not found
-
---*/
-{
-
-  EFI_FVB_ATTRIBUTES_2  Attributes;
-  UINTN                 LbaAddress;
-  EFI_FW_VOL_INSTANCE   *FwhInstance;
-  UINTN                 LbaLength;
-  EFI_STATUS            Status;
-
-  //
-  // Find the right instance of the FVB private data
-  //
-  Status = GetFvbInstance (Instance, Global, &FwhInstance, Virtual);
-  ASSERT_EFI_ERROR (Status);
-
-  //
-  // Writes are enabled in the init routine itself
-  //
-  if (!FwhInstance->WriteEnabled) {
-    return EFI_ACCESS_DENIED;
-  }
-  //
-  // Check if the FV is write enabled
-  //
-  FvbGetVolumeAttributes (Instance, &Attributes, Global, Virtual);
-
-  if ((Attributes & EFI_FVB2_WRITE_STATUS) == 0) {
-    return EFI_ACCESS_DENIED;
-  }
-  //
-  // Get the starting address of the block for erase. For debug reasons,
-  // LbaWriteAddress may not be the same as LbaAddress.
-  //
-  Status = FvbGetLbaAddress (Instance, Lba, &LbaAddress, &LbaLength, NULL, Global, Virtual);
-  if (EFI_ERROR (Status)) {
-    return Status;
-  }
-
-  return FlashFdErase (
-          LbaAddress,
-          FwhInstance,
-          LbaLength
-          );
-}
-
-EFI_STATUS
-FvbSetVolumeAttributes (
-  IN UINTN                                Instance,
-  IN OUT EFI_FVB_ATTRIBUTES_2             *Attributes,
-  IN ESAL_FWB_GLOBAL                      *Global,
-  IN BOOLEAN                              Virtual
-  )
-/*++
-
-Routine Description:
-  Modifies the current settings of the firmware volume according to the 
-  input parameter, and returns the new setting of the volume
-
-Arguments:
-  Instance              - The FV instance whose attributes is going to be 
-                          modified
-  Attributes            - On input, it is a pointer to EFI_FVB_ATTRIBUTES_2 
-                          containing the desired firmware volume settings.
-                          On successful return, it contains the new settings
-                          of the firmware volume
-  Global                - Pointer to ESAL_FWB_GLOBAL that contains all
-                          instance data
-  Virtual               - Whether CPU is in virtual or physical mode
-
-Returns: 
-  EFI_SUCCESS           - Successfully returns
-  EFI_ACCESS_DENIED     - The volume setting is locked and cannot be modified
-  EFI_INVALID_PARAMETER - Instance not found, or The attributes requested are
-                          in conflict with the capabilities as declared in the
-                          firmware volume header
-
---*/
-{
-  EFI_FW_VOL_INSTANCE   *FwhInstance;
-  EFI_FVB_ATTRIBUTES_2  OldAttributes;
-  EFI_FVB_ATTRIBUTES_2  *AttribPtr;
-  UINT32                Capabilities;
-  UINT32                OldStatus;
-  UINT32                NewStatus;
-  EFI_STATUS            Status;
-
-  //
-  // Find the right instance of the FVB private data
-  //
-  Status = GetFvbInstance (Instance, Global, &FwhInstance, Virtual);
-  ASSERT_EFI_ERROR (Status);
-
-  AttribPtr     = (EFI_FVB_ATTRIBUTES_2 *) &(FwhInstance->VolumeHeader.Attributes);
-  OldAttributes = *AttribPtr;
-  Capabilities  = OldAttributes & EFI_FVB2_CAPABILITIES;
-  OldStatus     = OldAttributes & EFI_FVB2_STATUS;
-  NewStatus     = *Attributes & EFI_FVB2_STATUS;
-
-  //
-  // If firmware volume is locked, no status bit can be updated
-  //
-  if (OldAttributes & EFI_FVB2_LOCK_STATUS) {
-    if (OldStatus ^ NewStatus) {
-      return EFI_ACCESS_DENIED;
-    }
-  }
-  //
-  // Test read disable
-  //
-  if ((Capabilities & EFI_FVB2_READ_DISABLED_CAP) == 0) {
-    if ((NewStatus & EFI_FVB2_READ_STATUS) == 0) {
-      return EFI_INVALID_PARAMETER;
-    }
-  }
-  //
-  // Test read enable
-  //
-  if ((Capabilities & EFI_FVB2_READ_ENABLED_CAP) == 0) {
-    if (NewStatus & EFI_FVB2_READ_STATUS) {
-      return EFI_INVALID_PARAMETER;
-    }
-  }
-  //
-  // Test write disable
-  //
-  if ((Capabilities & EFI_FVB2_WRITE_DISABLED_CAP) == 0) {
-    if ((NewStatus & EFI_FVB2_WRITE_STATUS) == 0) {
-      return EFI_INVALID_PARAMETER;
-    }
-  }
-  //
-  // Test write enable
-  //
-  if ((Capabilities & EFI_FVB2_WRITE_ENABLED_CAP) == 0) {
-    if (NewStatus & EFI_FVB2_WRITE_STATUS) {
-      return EFI_INVALID_PARAMETER;
-    }
-  }
-  //
-  // Test lock
-  //
-  if ((Capabilities & EFI_FVB2_LOCK_CAP) == 0) {
-    if (NewStatus & EFI_FVB2_LOCK_STATUS) {
-      return EFI_INVALID_PARAMETER;
-    }
-  }
-
-  *AttribPtr  = (*AttribPtr) & (0xFFFFFFFF & (~EFI_FVB2_STATUS));
-  *AttribPtr  = (*AttribPtr) | NewStatus;
-  *Attributes = *AttribPtr;
-
-  return EFI_SUCCESS;
-}
-//
-// FVB protocol APIs
-//
-EFI_STATUS
-EFIAPI
-FvbProtocolGetPhysicalAddress (
-  IN  CONST EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL          *This,
-  OUT       EFI_PHYSICAL_ADDRESS                        *Address
-  )
-/*++
-
-Routine Description:
-
-  Retrieves the physical address of the device.
-
-Arguments:
-
-  This                  - Calling context
-  Address               - Output buffer containing the address.
-
-Returns:
-
-Returns: 
-  EFI_SUCCESS           - Successfully returns
-
---*/
-{
-  EFI_FW_VOL_BLOCK_DEVICE *FvbDevice;
-
-  FvbDevice = FVB_DEVICE_FROM_THIS (This);
-
-  return FvbGetPhysicalAddress (FvbDevice->Instance, Address, mFvbModuleGlobal, EfiGoneVirtual ());
-}
-
-EFI_STATUS
-EFIAPI
-FvbProtocolGetBlockSize (
-  IN CONST EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL           *This,
-  IN  EFI_LBA                                     Lba,
-  OUT UINTN                                       *BlockSize,
-  OUT UINTN                                       *NumOfBlocks
-  )
-/*++
-
-Routine Description:
-  Retrieve the size of a logical block
-
-Arguments:
-  This                  - Calling context
-  Lba                   - Indicates which block to return the size for.
-  BlockSize             - A pointer to a caller allocated UINTN in which
-                          the size of the block is returned
-  NumOfBlocks           - a pointer to a caller allocated UINTN in which the
-                          number of consecutive blocks starting with Lba is
-                          returned. All blocks in this range have a size of
-                          BlockSize
-
-Returns: 
-  EFI_SUCCESS           - The firmware volume was read successfully and 
-                          contents are in Buffer
-
---*/
-{
-  EFI_FW_VOL_BLOCK_DEVICE *FvbDevice;
-
-  FvbDevice = FVB_DEVICE_FROM_THIS (This);
-
-  return FvbGetLbaAddress (
-          FvbDevice->Instance,
-          Lba,
-          NULL,
-          BlockSize,
-          NumOfBlocks,
-          mFvbModuleGlobal,
-          EfiGoneVirtual ()
-          );
-}
-
-EFI_STATUS
-EFIAPI
-FvbProtocolGetAttributes (
-  IN CONST EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL          *This,
-  OUT      EFI_FVB_ATTRIBUTES_2                        *Attributes
-  )
-/*++
-
-Routine Description:
-    Retrieves Volume attributes.  No polarity translations are done.
-
-Arguments:
-    This                - Calling context
-    Attributes          - output buffer which contains attributes
-
-Returns: 
-  EFI_SUCCESS           - Successfully returns
-
---*/
-{
-  EFI_FW_VOL_BLOCK_DEVICE *FvbDevice;
-
-  FvbDevice = FVB_DEVICE_FROM_THIS (This);
-
-  return FvbGetVolumeAttributes (FvbDevice->Instance, Attributes, mFvbModuleGlobal, EfiGoneVirtual ());
-}
-
-EFI_STATUS
-EFIAPI
-FvbProtocolSetAttributes (
-  IN CONST EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL       *This,
-  IN OUT   EFI_FVB_ATTRIBUTES_2                     *Attributes
-  )
-/*++
-
-Routine Description:
-  Sets Volume attributes. No polarity translations are done.
-
-Arguments:
-  This                  - Calling context
-  Attributes            - output buffer which contains attributes
-
-Returns: 
-  EFI_SUCCESS           - Successfully returns
-
---*/
-{
-  EFI_FW_VOL_BLOCK_DEVICE *FvbDevice;
-
-  FvbDevice = FVB_DEVICE_FROM_THIS (This);
-
-  return FvbSetVolumeAttributes (FvbDevice->Instance, Attributes, mFvbModuleGlobal, EfiGoneVirtual ());
-}
-
-EFI_STATUS
-EFIAPI
-FvbProtocolEraseBlocks (
-  IN CONST EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL    *This,
-  ...  
-  )
-/*++
-
-Routine Description:
-
-  The EraseBlock() function erases one or more blocks as denoted by the 
-  variable argument list. The entire parameter list of blocks must be verified
-  prior to erasing any blocks.  If a block is requested that does not exist 
-  within the associated firmware volume (it has a larger index than the last 
-  block of the firmware volume), the EraseBlock() function must return
-  EFI_INVALID_PARAMETER without modifying the contents of the firmware volume.
-
-Arguments:
-  This                  - Calling context
-  ...                   - Starting LBA followed by Number of Lba to erase. 
-                          a -1 to terminate the list.
-
-Returns: 
-  EFI_SUCCESS           - The erase request was successfully completed
-  EFI_ACCESS_DENIED     - The firmware volume is in the WriteDisabled state
-  EFI_DEVICE_ERROR      - The block device is not functioning correctly and 
-                          could not be written. Firmware device may have been
-                          partially erased
-
---*/
-{
-  EFI_FW_VOL_BLOCK_DEVICE *FvbDevice;
-  EFI_FW_VOL_INSTANCE     *FwhInstance;
-  UINTN                   NumOfBlocks;
-  VA_LIST                 args;
-  EFI_LBA                 StartingLba;
-  UINTN                   NumOfLba;
-  EFI_STATUS              Status;
-
-  FvbDevice = FVB_DEVICE_FROM_THIS (This);
-
-  Status    = GetFvbInstance (FvbDevice->Instance, mFvbModuleGlobal, &FwhInstance, EfiGoneVirtual ());
-  ASSERT_EFI_ERROR (Status);
-
-  NumOfBlocks = FwhInstance->NumOfBlocks;
-
-  VA_START (args, This);
-
-  do {
-    StartingLba = VA_ARG (args, EFI_LBA);
-    if (StartingLba == EFI_LBA_LIST_TERMINATOR) {
-      break;
-    }
-
-    NumOfLba = VA_ARG (args, UINT32);
-
-    //
-    // Check input parameters
-    //
-    if ((NumOfLba == 0) || ((StartingLba + NumOfLba) > NumOfBlocks)) {
-      VA_END (args);
-      return EFI_INVALID_PARAMETER;
-    }
-  } while (1);
-
-  VA_END (args);
-
-  VA_START (args, This);
-  do {
-    StartingLba = VA_ARG (args, EFI_LBA);
-    if (StartingLba == EFI_LBA_LIST_TERMINATOR) {
-      break;
-    }
-
-    NumOfLba = VA_ARG (args, UINT32);
-
-    while (NumOfLba > 0) {
-      Status = FvbEraseBlock (FvbDevice->Instance, StartingLba, mFvbModuleGlobal, EfiGoneVirtual ());
-      if (EFI_ERROR (Status)) {
-        VA_END (args);
-        return Status;
-      }
-
-      StartingLba++;
-      NumOfLba--;
-    }
-
-  } while (1);
-
-  VA_END (args);
-
-  return EFI_SUCCESS;
-}
-
-EFI_STATUS
-EFIAPI
-FvbProtocolWrite (
-  IN CONST EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL     *This,
-  IN EFI_LBA                                      Lba,
-  IN UINTN                                        Offset,
-  IN OUT UINTN                                    *NumBytes,
-  IN UINT8                                        *Buffer
-  )
-/*++
-
-Routine Description:
-
-  Writes data beginning at Lba:Offset from FV. The write terminates either
-  when *NumBytes of data have been written, or when a block boundary is
-  reached.  *NumBytes is updated to reflect the actual number of bytes
-  written. The write opertion does not include erase. This routine will
-  attempt to write only the specified bytes. If the writes do not stick,
-  it will return an error.
-
-Arguments:
-  This                  - Calling context
-  Lba                   - Block in which to begin write
-  Offset                - Offset in the block at which to begin write
-  NumBytes              - On input, indicates the requested write size. On
-                          output, indicates the actual number of bytes written
-  Buffer                - Buffer containing source data for the write.
-
-Returns: 
-  EFI_SUCCESS           - The firmware volume was written successfully
-  EFI_BAD_BUFFER_SIZE   - Write attempted across a LBA boundary. On output,
-                          NumBytes contains the total number of bytes
-                          actually written
-  EFI_ACCESS_DENIED     - The firmware volume is in the WriteDisabled state
-  EFI_DEVICE_ERROR      - The block device is not functioning correctly and 
-                          could not be written
-  EFI_INVALID_PARAMETER - NumBytes or Buffer are NULL
-
---*/
-{
-
-  EFI_FW_VOL_BLOCK_DEVICE *FvbDevice;
-
-  FvbDevice = FVB_DEVICE_FROM_THIS (This);
-
-  return FvbWriteBlock (FvbDevice->Instance, Lba, Offset, NumBytes, Buffer, mFvbModuleGlobal, EfiGoneVirtual ());
-}
-
-EFI_STATUS
-EFIAPI
-FvbProtocolRead (
-  IN CONST EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL     *This,
-  IN EFI_LBA                                      Lba,
-  IN UINTN                                        Offset,
-  IN OUT UINTN                                    *NumBytes,
-  IN UINT8                                        *Buffer
-  )
-/*++
-
-Routine Description:
-
-  Reads data beginning at Lba:Offset from FV. The Read terminates either
-  when *NumBytes of data have been read, or when a block boundary is
-  reached.  *NumBytes is updated to reflect the actual number of bytes
-  written. The write opertion does not include erase. This routine will
-  attempt to write only the specified bytes. If the writes do not stick,
-  it will return an error.
-
-Arguments:
-  This                  - Calling context
-  Lba                   - Block in which to begin Read
-  Offset                - Offset in the block at which to begin Read
-  NumBytes              - On input, indicates the requested write size. On
-                          output, indicates the actual number of bytes Read
-  Buffer                - Buffer containing source data for the Read.
-
-Returns: 
-  EFI_SUCCESS           - The firmware volume was read successfully and 
-                          contents are in Buffer
-  EFI_BAD_BUFFER_SIZE   - Read attempted across a LBA boundary. On output,
-                          NumBytes contains the total number of bytes returned
-                          in Buffer
-  EFI_ACCESS_DENIED     - The firmware volume is in the ReadDisabled state
-  EFI_DEVICE_ERROR      - The block device is not functioning correctly and 
-                          could not be read
-  EFI_INVALID_PARAMETER - NumBytes or Buffer are NULL
-
---*/
-{
-
-  EFI_FW_VOL_BLOCK_DEVICE *FvbDevice;
-
-  FvbDevice = FVB_DEVICE_FROM_THIS (This);
-
-  return FvbReadBlock (FvbDevice->Instance, Lba, Offset, NumBytes, Buffer, mFvbModuleGlobal, EfiGoneVirtual ());
-}
-
-EFI_STATUS
-ValidateFvHeader (
-  EFI_FIRMWARE_VOLUME_HEADER            *FwVolHeader
-  )
-/*++
-
-Routine Description:
-  Check the integrity of firmware volume header
-
-Arguments:
-  FwVolHeader           - A pointer to a firmware volume header
-
-Returns: 
-  EFI_SUCCESS           - The firmware volume is consistent
-  EFI_NOT_FOUND         - The firmware volume has corrupted. So it is not an FV
-
---*/
-{
-  UINT16  *Ptr;
-  UINT16  HeaderLength;
-  UINT16  Checksum;
-
-  //
-  // Verify the header revision, header signature, length
-  // Length of FvBlock cannot be 2**64-1
-  // HeaderLength cannot be an odd number
-  //
-  if ((FwVolHeader->Revision != EFI_FVH_REVISION) ||
-      (FwVolHeader->Signature != EFI_FVH_SIGNATURE) ||
-      (FwVolHeader->FvLength == ((UINTN) -1)) ||
-      ((FwVolHeader->HeaderLength & 0x01) != 0)
-      ) {
-    return EFI_NOT_FOUND;
-  }
-  //
-  // Verify the header checksum
-  //
-  HeaderLength  = (UINT16) (FwVolHeader->HeaderLength / 2);
-  Ptr           = (UINT16 *) FwVolHeader;
-  Checksum      = 0;
-  while (HeaderLength > 0) {
-    Checksum = Checksum + (*Ptr);
-    HeaderLength--;
-    Ptr++;
-  }
-
-  if (Checksum != 0) {
-    return EFI_NOT_FOUND;
-  }
-
-  return EFI_SUCCESS;
-}
-
-
-EFI_STATUS
-GetFvbHeader (
-  IN OUT EFI_PEI_HOB_POINTERS           *HobList,
-  OUT    EFI_FIRMWARE_VOLUME_HEADER     **FwVolHeader,
-  OUT    EFI_PHYSICAL_ADDRESS           *BaseAddress     OPTIONAL,
-  OUT    UINT32                         *VolumeId        OPTIONAL,
-  OUT    CHAR16                         **MappedFile     OPTIONAL,
-  OUT    UINT32                         *ActuralSize     OPTIONAL,
-  OUT    UINT32                         *Offset          OPTIONAL,
-  OUT    BOOLEAN                        *WriteBack       OPTIONAL
-  )
-{
-  EFI_STATUS                  Status;
-  EFI_FLASH_MAP_FS_ENTRY_DATA *FlashMapEntry;
-  EFI_FLASH_SUBAREA_ENTRY     *FlashMapSubEntry;
-
-  Status        = EFI_SUCCESS;
-  *FwVolHeader  = NULL;
-  TRY_ASSIGN (WriteBack, FALSE);
-
-  DEBUG ((EFI_D_INFO, "Hob start is 0x%x\n", (UINTN)(*HobList).Raw));
-  (*HobList).Raw = GetNextGuidHob (&gEfiFlashMapHobGuid, (*HobList).Raw);
-  if ((*HobList).Raw == NULL) {
-    return EFI_NOT_FOUND;
-  }
-
-  FlashMapEntry     = (EFI_FLASH_MAP_FS_ENTRY_DATA *) GET_GUID_HOB_DATA ((*HobList).Guid);
-  FlashMapSubEntry  = &FlashMapEntry->Entries[0];
-  
-  //
-  // Check if it is a "FVB" area
-  //
-  if (!CompareGuid (&FlashMapSubEntry->FileSystem, &gEfiFirmwareVolumeBlockProtocolGuid)) {
-    return Status;
-  }
-  //
-  // Check if it is a "real" flash
-  //
-  if (FlashMapSubEntry->Attributes != (EFI_FLASH_AREA_FV | EFI_FLASH_AREA_MEMMAPPED_FV)) {
-    return Status;
-  }
-
-  TRY_ASSIGN (BaseAddress, FlashMapSubEntry->Base);
-
-  //
-  // Cast buffer to FLASH_AREA_INFO to get extra information related to the special FVB driver
-  //
-  TRY_ASSIGN (VolumeId,    FlashMapEntry->VolumeId);
-  TRY_ASSIGN (ActuralSize, FlashMapEntry->ActuralSize);
-  TRY_ASSIGN (MappedFile, ((CHAR16 *) FlashMapEntry->FilePath));
-  TRY_ASSIGN (Offset,      FlashMapEntry->Offset);
-
-  DEBUG ((
-    EFI_D_INFO, 
-    "FlashMap HOB: BaseAddress = 0x%x, Length = 0x%x, ActuralLength = 0x%x, Offset = 0x%x\n", 
-    (UINTN) FlashMapSubEntry->Base, (UINTN) FlashMapSubEntry->Length, 
-    (UINTN) FlashMapEntry->ActuralSize, (UINTN) FlashMapEntry->Offset
-  ));
-  DEBUG ((
-    EFI_D_INFO,
-    "FlashMap HOB: VolumeId = 0x%lx, MappedFile = %s\n",
-    (UINTN) FlashMapEntry->VolumeId, (UINTN) FlashMapEntry->FilePath
-  ));
-  *FwVolHeader  = (EFI_FIRMWARE_VOLUME_HEADER *) (UINTN) (FlashMapSubEntry->Base);
-  Status        = ValidateFvHeader (*FwVolHeader);
-  if (EFI_ERROR (Status)) {
-    //
-    // Get FvbInfo
-    //
-    TRY_ASSIGN (WriteBack, TRUE);
-    Status = GetFvbInfo (FlashMapSubEntry->Length, FwVolHeader);
-    DEBUG ((EFI_D_ERROR, "Fvb: FV header invalid, GetFvbInfo - %r\n", Status));
-    ASSERT_EFI_ERROR (Status);
-  }
-
-  return EFI_SUCCESS;
-}
-
-VOID
-EFIAPI
-OnSimpleFileSystemInstall (
-  IN EFI_EVENT        Event,
-  IN VOID             *Context
-  )
-{
-  EFI_STATUS                Status;
-  UINTN                     HandleSize;
-  EFI_HANDLE                Handle;
-  UINTN                     Instance;
-  EFI_DEVICE_PATH_PROTOCOL  *Device;
-  EFI_FILE_PROTOCOL         *File;
-  EFI_FW_VOL_INSTANCE       *FwhInstance;
-  while (TRUE) {
-    HandleSize = sizeof (EFI_HANDLE);
-    Status = gBS->LocateHandle (
-                    ByRegisterNotify,
-                    NULL,
-                    mSFSRegistration,
-                    &HandleSize,
-                    &Handle
-                    );
-    if (Status == EFI_NOT_FOUND) {
-      break;
-    }
-    DEBUG ((EFI_D_ERROR, "Fwh: New FileSystem Installed!\n"));
-    ASSERT_EFI_ERROR (Status);
-    //
-    // Check if this is the storage we care about, and store it in FwhInstance
-    //
-    for (Instance = 0; Instance < mFvbModuleGlobal->NumFv; ++Instance) {
-      Status = GetFvbInstance (Instance, mFvbModuleGlobal, &FwhInstance, FALSE);
-      ASSERT_EFI_ERROR (Status);
-
-      if (FwhInstance->MappedFile[0] == L'\0') {
-        //
-        // The instance of FVB isn't mapped to file.
-        //
-        continue;
-      }
-
-      if ((FwhInstance->Device != NULL) && 
-          !EFI_ERROR (CheckStoreExists (FwhInstance->Device))
-          ) {
-        //
-        // The instance of FVB has already associated to a device
-        //  and the device is not removed from system.
-        //
-        DEBUG ((
-              EFI_D_ERROR, "Fwh: MappedFile FVB (0x%x:0x%x) - Already mapped, Skip!\n", 
-              (UINTN) FwhInstance->FvBase[FVB_PHYSICAL],
-              (UINTN) FwhInstance->Offset
-              ));
-        continue;
-      }
-
-      Status = CheckStore (Handle, FwhInstance->VolumeId, &Device);
-      if (!EFI_ERROR (Status)) {
-        //
-        // Write back memory content to file
-        //
-        Status = FileOpen (Device, FwhInstance->MappedFile, &File, EFI_FILE_MODE_WRITE | EFI_FILE_MODE_READ | EFI_FILE_MODE_CREATE);
-        ASSERT_EFI_ERROR (Status); 
-        if (!EFI_ERROR (Status)) {
-          DEBUG ((
-                EFI_D_ERROR, "Fwh: MappedFile FVB (0x%x:0x%x) - Write back to mapped file!\n", 
-                (UINTN) FwhInstance->FvBase[FVB_PHYSICAL],
-                (UINTN) FwhInstance->Offset
-                ));
-          Status = FileWrite (
-                     File, 
-                     0, 
-                     FwhInstance->FvBase[FVB_PHYSICAL] + FwhInstance->Offset, 
-                     FwhInstance->ActuralSize - FwhInstance->Offset
-                     );
-          ASSERT_EFI_ERROR (Status); 
-          if (!EFI_ERROR (Status)) {
-            if (FwhInstance->Device != NULL) {
-              gBS->FreePool (FwhInstance->Device);
-            }
-            FwhInstance->Device = Device;
-            DEBUG ((
-                  EFI_D_ERROR, "Fwh: MappedFile FVB (0x%x:0x%x) - Mapped!\n",
-                  (UINTN) FwhInstance->FvBase[FVB_PHYSICAL],
-                  (UINTN) FwhInstance->Offset
-                  ));
-          }
-          FileClose (File);
-        }
-      }
-    }
-  }
-}
-
-VOID
-FvbInstallSfsNotify (
-  VOID
-)
-{
-  EFI_STATUS Status;
-  EFI_EVENT  Event;
-
-  Status = gBS->CreateEvent (
-                  EVT_NOTIFY_SIGNAL,
-                  TPL_CALLBACK,
-                  OnSimpleFileSystemInstall,
-                  NULL,
-                  &Event
-                  );
-  ASSERT_EFI_ERROR (Status);
-
-  Status = gBS->RegisterProtocolNotify (
-                  &gEfiSimpleFileSystemProtocolGuid,
-                  Event,
-                  &mSFSRegistration
-                  );
-  ASSERT_EFI_ERROR (Status);
-}
-
-
-EFI_STATUS
-EFIAPI
-FvbInitialize (
-  IN EFI_HANDLE         ImageHandle,
-  IN EFI_SYSTEM_TABLE   *SystemTable
-  )
-/*++
-
-Routine Description:
-  This function does common initialization for FVB services
-
-Arguments:
-
-Returns:
-
---*/
-{
-  EFI_STATUS                          Status;
-  EFI_FW_VOL_INSTANCE                 *FwhInstance;
-  EFI_FIRMWARE_VOLUME_HEADER          *FwVolHeader;
-  EFI_PEI_HOB_POINTERS                FirmwareVolumeHobList;
-  UINT32                              BufferSize;
-  EFI_FV_BLOCK_MAP_ENTRY              *PtrBlockMapEntry;
-  UINTN                               LbaAddress;
-  EFI_HANDLE                          FwbHandle;
-  EFI_FW_VOL_BLOCK_DEVICE             *FvbDevice;
-  EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL  *OldFwbInterface;
-  EFI_DEVICE_PATH_PROTOCOL            *TempFwbDevicePath;
-  FV_DEVICE_PATH                      TempFvbDevicePathData;
-  UINT32                              MaxLbaSize;
-  EFI_PHYSICAL_ADDRESS                BaseAddress;
-  UINT32                              VolumeId;
-  CHAR16                              *MappedFile;
-  UINT32                              ActuralSize;
-  UINT32                              Offset;
-  BOOLEAN                             WriteBack;
-  UINTN                               NumOfBlocks;
-  UINTN                               HeaderLength;
-  BOOLEAN                             InstallSfsNotify;
-
-  HeaderLength     = 0;
-  InstallSfsNotify = FALSE;
-
-  //
-  // Allocate runtime services data for global variable, which contains
-  // the private data of all firmware volume block instances
-  //
-  Status = gBS->AllocatePool (
-                  EfiRuntimeServicesData,
-                  sizeof (ESAL_FWB_GLOBAL),
-                  &mFvbModuleGlobal
-                  );
-  ASSERT_EFI_ERROR (Status);
-  //
-  // Calculate the total size for all firmware volume block instances
-  //
-  BufferSize            = 0;
-  FirmwareVolumeHobList.Raw = GetHobList();
-  do {
-    Status = GetFvbHeader (&FirmwareVolumeHobList, &FwVolHeader, NULL, NULL, NULL, NULL, NULL, NULL);
-    if (EFI_ERROR (Status)) {
-      break;
-    }
-    FirmwareVolumeHobList.Raw = GET_NEXT_HOB (FirmwareVolumeHobList);
-
-    if (FwVolHeader) {
-      BufferSize += (FwVolHeader->HeaderLength + sizeof (EFI_FW_VOL_INSTANCE) - sizeof (EFI_FIRMWARE_VOLUME_HEADER));
-    }
-  } while (TRUE);
-
-  //
-  // Only need to allocate once. There is only one copy of physical memory for
-  // the private data of each FV instance. But in virtual mode or in physical
-  // mode, the address of the the physical memory may be different.
-  //
-  Status = gBS->AllocatePool (
-                  EfiRuntimeServicesData,
-                  BufferSize,
-                  &mFvbModuleGlobal->FvInstance[FVB_PHYSICAL]
-                  );
-  ASSERT_EFI_ERROR (Status);
-
-  //
-  // Make a virtual copy of the FvInstance pointer.
-  //
-  FwhInstance = mFvbModuleGlobal->FvInstance[FVB_PHYSICAL];
-  mFvbModuleGlobal->FvInstance[FVB_VIRTUAL] = FwhInstance;
-
-  mFvbModuleGlobal->NumFv     = 0;
-  FirmwareVolumeHobList.Raw   = GetHobList();
-  MaxLbaSize                  = 0;
-
-  //
-  // Fill in the private data of each firmware volume block instance
-  //
-  do {
-    Status = GetFvbHeader (
-               &FirmwareVolumeHobList, &FwVolHeader, 
-               &BaseAddress, &VolumeId, &MappedFile, &ActuralSize, &Offset,
-               &WriteBack
-             );
-    if (EFI_ERROR (Status)) {
-      break;
-    }
-    FirmwareVolumeHobList.Raw = GET_NEXT_HOB (FirmwareVolumeHobList);
-
-    if (!FwVolHeader) {
-      continue;
-    }
-    
-    CopyMem ((UINTN *) &(FwhInstance->VolumeHeader), (UINTN *) FwVolHeader, FwVolHeader->HeaderLength);
-    FwVolHeader                       = &(FwhInstance->VolumeHeader);
-
-    FwhInstance->FvBase[FVB_PHYSICAL] = (UINTN) BaseAddress;
-    FwhInstance->FvBase[FVB_VIRTUAL]  = (UINTN) BaseAddress;
-    FwhInstance->Device               = NULL;
-    FwhInstance->Offset               = Offset;
-
-    if (*MappedFile != '\0') {
-      FwhInstance->VolumeId             = VolumeId;
-      FwhInstance->ActuralSize          = ActuralSize;
-      StrCpy (FwhInstance->MappedFile, MappedFile);
-
-      InstallSfsNotify = TRUE;
-    } else {
-      FwhInstance->VolumeId             = (UINT32) -1;
-      FwhInstance->ActuralSize          = (UINT32) -1;
-      FwhInstance->MappedFile[0]        = L'\0';
-    }
-    
-    DEBUG ((EFI_D_INFO, "FirmVolume Found! BaseAddress=0x%lx, VolumeId=0x%x, MappedFile=%s, Size=0x%x\n",
-           (UINTN) BaseAddress, VolumeId, MappedFile, ActuralSize));
-    //
-    // We may expose readonly FVB in future.
-    //
-    FwhInstance->WriteEnabled         = TRUE; // Ken: Why enable write?
-    EfiInitializeLock (&(FwhInstance->FvbDevLock), TPL_HIGH_LEVEL);
-
-    LbaAddress  = (UINTN) FwhInstance->FvBase[0];
-    NumOfBlocks = 0;
-
-    if (FwhInstance->WriteEnabled) {
-      for (PtrBlockMapEntry = FwVolHeader->BlockMap; PtrBlockMapEntry->NumBlocks != 0; PtrBlockMapEntry++) {
-
-        LbaAddress += PtrBlockMapEntry->NumBlocks * PtrBlockMapEntry->Length;
-        //
-        // Get the maximum size of a block. The size will be used to allocate
-        // buffer for Scratch space, the intermediate buffer for FVB extension
-        // protocol
-        //
-        if (MaxLbaSize < PtrBlockMapEntry->Length) {
-          MaxLbaSize = PtrBlockMapEntry->Length;
-        }
-
-        NumOfBlocks += PtrBlockMapEntry->NumBlocks;
-      }
-      //
-      //  Write back a healthy FV header
-      //
-      if (WriteBack) {
-        Status = FlashFdErase (
-                  (UINTN) FwhInstance->FvBase[0],
-                  FwhInstance,
-                  FwVolHeader->BlockMap->Length
-                  );
-
-        HeaderLength = (UINTN) FwVolHeader->HeaderLength;
-
-        Status = FlashFdWrite (
-                  (UINTN) FwhInstance->FvBase[0],
-                  FwhInstance,
-                  (UINTN *) &HeaderLength,
-                  (UINT8 *) FwVolHeader
-                  );
-
-        FwVolHeader->HeaderLength = (UINT16) HeaderLength;
-
-        DEBUG ((EFI_D_ERROR, "Fvb (0x%x): FV header invalid, write back - %r\n", (UINTN) FwhInstance->FvBase[0], Status));
-      }
-    }
-    //
-    // The total number of blocks in the FV.
-    //
-    FwhInstance->NumOfBlocks = NumOfBlocks;
-
-    //
-    // Add a FVB Protocol Instance
-    //
-    Status = gBS->AllocatePool (
-                    EfiRuntimeServicesData,
-                    sizeof (EFI_FW_VOL_BLOCK_DEVICE),
-                    &FvbDevice
-                    );
-    ASSERT_EFI_ERROR (Status);
-
-    CopyMem (FvbDevice, &mFvbDeviceTemplate, sizeof (EFI_FW_VOL_BLOCK_DEVICE));
-
-    FvbDevice->Instance = mFvbModuleGlobal->NumFv;
-    mFvbModuleGlobal->NumFv++;
-
-    //
-    // Set up the devicepath
-    //
-    FvbDevice->DevicePath.MemMapDevPath.StartingAddress = BaseAddress;
-    FvbDevice->DevicePath.MemMapDevPath.EndingAddress   = BaseAddress + (FwVolHeader->FvLength - 1);
-
-    //
-    // Find a handle with a matching device path that has supports FW Block protocol
-    //
-    TempFwbDevicePath = (EFI_DEVICE_PATH_PROTOCOL *) &TempFvbDevicePathData;
-    CopyMem (TempFwbDevicePath, &FvbDevice->DevicePath, sizeof (FV_DEVICE_PATH));
-    Status = gBS->LocateDevicePath (&gEfiFirmwareVolumeBlockProtocolGuid, &TempFwbDevicePath, &FwbHandle);
-    if (EFI_ERROR (Status)) {
-      //
-      // LocateDevicePath fails so install a new interface and device path
-      //
-      FwbHandle = NULL;
-      Status = gBS->InstallMultipleProtocolInterfaces (
-                      &FwbHandle,
-                      &gEfiFirmwareVolumeBlockProtocolGuid,
-                      &FvbDevice->FwVolBlockInstance,
-                      &gEfiDevicePathProtocolGuid,
-                      &FvbDevice->DevicePath,
-                      NULL
-                      );
-      ASSERT_EFI_ERROR (Status);
-    } else if (IsDevicePathEnd (TempFwbDevicePath)) {
-      //
-      // Device allready exists, so reinstall the FVB protocol
-      //
-      Status = gBS->HandleProtocol (
-                      FwbHandle,
-                      &gEfiFirmwareVolumeBlockProtocolGuid,
-                      &OldFwbInterface
-                      );
-      ASSERT_EFI_ERROR (Status);
-
-      Status = gBS->ReinstallProtocolInterface (
-                      FwbHandle,
-                      &gEfiFirmwareVolumeBlockProtocolGuid,
-                      OldFwbInterface,
-                      &FvbDevice->FwVolBlockInstance
-                      );
-      ASSERT_EFI_ERROR (Status);
-
-    } else {
-      //
-      // There was a FVB protocol on an End Device Path node
-      //
-      ASSERT (FALSE);
-    }
-
-    FwhInstance = (EFI_FW_VOL_INSTANCE *)
-      (
-        (UINTN) ((UINT8 *) FwhInstance) + FwVolHeader->HeaderLength +
-          (sizeof (EFI_FW_VOL_INSTANCE) - sizeof (EFI_FIRMWARE_VOLUME_HEADER))
-      );
-  } while (TRUE);
-
-  //
-  // Allocate for scratch space, an intermediate buffer for FVB extention
-  //
-  Status = gBS->AllocatePool (
-                  EfiRuntimeServicesData,
-                  MaxLbaSize,
-                  &mFvbModuleGlobal->FvbScratchSpace[FVB_PHYSICAL]
-                  );
-  ASSERT_EFI_ERROR (Status);
-
-  mFvbModuleGlobal->FvbScratchSpace[FVB_VIRTUAL] = mFvbModuleGlobal->FvbScratchSpace[FVB_PHYSICAL];
-
-  if (InstallSfsNotify) {
-    FvbInstallSfsNotify ();
-  }
-  return EFI_SUCCESS;
-}
Index: DuetPkg/FvbRuntimeService/FileIo.c
===================================================================
--- DuetPkg/FvbRuntimeService/FileIo.c	(revision 1)
+++ DuetPkg/FvbRuntimeService/FileIo.c	(working copy)
@@ -1,210 +0,0 @@
-/**@file
-Copyright (c) 2007 - 2009, Intel Corporation. All rights reserved.<BR>
-This program and the accompanying materials
-are licensed and made available under the terms and conditions of the BSD License
-which accompanies this distribution.  The full text of the license may be found at
-http://opensource.org/licenses/bsd-license.php
-
-THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-Module Name:
-
-    FileIo.c
-
-Abstract:
-
-  File operation for Firmware volume block driver
-
-**/
-#include "FileIo.h"
-
-//
-// Variable storage hot plug is supported but there are still some restrictions:
-// After plugging the storage back,
-// 1. Still use memory as NV if newly plugged storage is not same as the original one
-// 2. Still use memory as NV if there are some update operation during storage is unplugged.
-//
-
-
-EFI_STATUS
-FileWrite (
-  IN EFI_FILE_PROTOCOL  *File,
-  IN UINTN              Offset,
-  IN UINTN              Buffer,
-  IN UINTN              Size
-  )
-{
-  EFI_STATUS Status;
-
-  Status = File->SetPosition (File, Offset);
-  ASSERT_EFI_ERROR (Status);
-  if (!EFI_ERROR (Status)) {
-    Status = File->Write (File, &Size, (VOID *) Buffer);
-    ASSERT_EFI_ERROR (Status);
-  }
-  return Status;
-}
-
-EFI_STATUS
-CheckStore (
-  IN  EFI_HANDLE                 SimpleFileSystemHandle,
-  IN  UINT32                     VolumeId,
-  OUT EFI_DEVICE_PATH_PROTOCOL   **Device
-  )
-{
-#define BLOCK_SIZE              0x200
-#define FAT16_VOLUME_ID_OFFSET  39
-#define FAT32_VOLUME_ID_OFFSET  67
-  EFI_STATUS                      Status;
-  EFI_BLOCK_IO_PROTOCOL           *BlkIo;
-  UINT8                           BootSector[BLOCK_SIZE];
-
-  *Device = NULL;
-  Status  = gBS->HandleProtocol (
-                   SimpleFileSystemHandle,
-                   &gEfiBlockIoProtocolGuid, // BlockIo should be supported if it supports SimpleFileSystem
-                   (VOID*)&BlkIo
-                   );
-
-  if (EFI_ERROR (Status)) {
-    goto ErrHandle;
-  }
-  if (!BlkIo->Media->MediaPresent) {
-    DEBUG ((EFI_D_ERROR, "FwhMappedFile: Media not present!\n"));
-    Status = EFI_NO_MEDIA;
-    goto ErrHandle;
-  }
-  if (BlkIo->Media->ReadOnly) {
-    DEBUG ((EFI_D_ERROR, "FwhMappedFile: Media is read-only!\n"));
-    Status = EFI_ACCESS_DENIED;
-    goto ErrHandle;
-  }
-
-  Status = BlkIo->ReadBlocks(
-                    BlkIo,
-                    BlkIo->Media->MediaId,
-                    0,
-                    BLOCK_SIZE,
-                    BootSector
-                    );
-  ASSERT_EFI_ERROR (Status);
-  if ((*(UINT32 *) &BootSector[FAT16_VOLUME_ID_OFFSET] != VolumeId) &&
-      (*(UINT32 *) &BootSector[FAT32_VOLUME_ID_OFFSET] != VolumeId)
-      ) {
-    Status = EFI_NOT_FOUND;
-    goto ErrHandle;
-  }
-
-  *Device = DuplicateDevicePath (DevicePathFromHandle (SimpleFileSystemHandle));
-  ASSERT (*Device != NULL);
-
-ErrHandle:
-  return Status;
-}
-
-EFI_STATUS
-CheckStoreExists (
-  IN  EFI_DEVICE_PATH_PROTOCOL   *Device
-  )
-{
-  EFI_HANDLE                        Handle;
-  EFI_SIMPLE_FILE_SYSTEM_PROTOCOL   *Volume;
-  EFI_STATUS                        Status;
-
-  Status = gBS->LocateDevicePath (
-                  &gEfiSimpleFileSystemProtocolGuid,
-                  &Device, 
-                  &Handle
-                  );
-
-  if (EFI_ERROR (Status)) {
-    return Status;
-  }
-
-  Status = gBS->HandleProtocol (
-                  Handle,
-                  &gEfiSimpleFileSystemProtocolGuid,
-                  &Volume
-                  );
-  if (EFI_ERROR (Status)) {
-    return Status;
-  }
-
-  return EFI_SUCCESS;
-}
-
-VOID
-FileClose (
-  IN  EFI_FILE_PROTOCOL          *File
-  )
-{
-  File->Flush (File);
-  File->Close (File);
-}
-EFI_STATUS
-FileOpen (
-  IN  EFI_DEVICE_PATH_PROTOCOL   *Device,
-  IN  CHAR16                     *MappedFile,
-  OUT EFI_FILE_PROTOCOL          **File,
-  IN  UINT64                     OpenMode
-  )
-{  
-  EFI_HANDLE                        Handle;
-  EFI_FILE_HANDLE                   Root;
-  EFI_SIMPLE_FILE_SYSTEM_PROTOCOL   *Volume;
-  EFI_STATUS                        Status;
-
-  *File = NULL;
-
-  Status = gBS->LocateDevicePath (
-                  &gEfiSimpleFileSystemProtocolGuid,
-                  &Device, 
-                  &Handle
-                  );
-
-  if (EFI_ERROR (Status)) {
-    return Status;
-  }
-
-  Status = gBS->HandleProtocol (
-                  Handle,
-                  &gEfiSimpleFileSystemProtocolGuid,
-                  &Volume
-                  );
-  ASSERT_EFI_ERROR (Status);
-  if (EFI_ERROR (Status)) {
-    return Status;
-  }
-  
-  //
-  // Open the root directory of the volume
-  //
-  Root = NULL;
-  Status = Volume->OpenVolume (
-                     Volume,
-                     &Root
-                     );
-  ASSERT_EFI_ERROR (Status);
-  ASSERT (Root != NULL);
-
-  //
-  // Open file
-  //
-  Status = Root->Open (
-                   Root,
-                   File,
-                   MappedFile,
-                   OpenMode,
-                   0
-                   );
-  if (EFI_ERROR (Status)) {
-    *File = NULL;
-  }
-
-  //
-  // Close the Root directory
-  //
-  Root->Close (Root);
-  return Status;
-}
Index: DuetPkg/FvbRuntimeService/FileIo.h
===================================================================
--- DuetPkg/FvbRuntimeService/FileIo.h	(revision 1)
+++ DuetPkg/FvbRuntimeService/FileIo.h	(working copy)
@@ -1,58 +0,0 @@
-/**@file
-Copyright (c) 2007 - 2009, Intel Corporation. All rights reserved.<BR>
-This program and the accompanying materials                          
-are licensed and made available under the terms and conditions of the BSD License         
-which accompanies this distribution.  The full text of the license may be found at        
-http://opensource.org/licenses/bsd-license.php                                            
-                                                                                          
-THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,                     
-WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.             
-
-Module Name:
-
-  FileIo.h
-  
-Abstract:
-
-  File operation for Firmware volume block driver
-
-**/
-#ifndef _FW_BLOCK_SERVICE_FILE_IO_H
-#define _FW_BLOCK_SERVICE_FILE_IO_H
-
-#include "FwBlockService.h"
-
-EFI_STATUS
-FileWrite (
-  IN EFI_FILE_PROTOCOL  *File,
-  IN UINTN              Offset,
-  IN UINTN              Buffer,
-  IN UINTN              Size
-  );
-
-EFI_STATUS
-CheckStore (
-  IN  EFI_HANDLE                 SimpleFileSystemHandle,
-  IN  UINT32                     VolumeId,
-  OUT EFI_DEVICE_PATH_PROTOCOL   **Device
-  );
-
-EFI_STATUS
-CheckStoreExists (
-  IN  EFI_DEVICE_PATH_PROTOCOL   *Device
-  );
-
-EFI_STATUS
-FileOpen (
-  IN  EFI_DEVICE_PATH_PROTOCOL   *Device,
-  IN  CHAR16                     *MappedFile,
-  OUT EFI_FILE_PROTOCOL          **File,
-  IN  UINT64                     OpenMode
-  );
-
-VOID
-FileClose (
-  IN  EFI_FILE_PROTOCOL          *File
-  );
-
-#endif // _FW_BLOCK_SERVICE_FILE_IO_H
Index: DuetPkg/FvbRuntimeService/FvbInfo.c
===================================================================
--- DuetPkg/FvbRuntimeService/FvbInfo.c	(revision 1)
+++ DuetPkg/FvbRuntimeService/FvbInfo.c	(working copy)
@@ -1,121 +0,0 @@
-/**@file
-Copyright (c) 2007, Intel Corporation. All rights reserved.<BR>
-This program and the accompanying materials                          
-are licensed and made available under the terms and conditions of the BSD License         
-which accompanies this distribution.  The full text of the license may be found at        
-http://opensource.org/licenses/bsd-license.php                                            
-                                                                                          
-THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,                     
-WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.             
-
-Module Name:
-
-  FvbInfo.c
-
-Abstract:
-
-  Defines data structure that is the volume header found.These data is intent
-  to decouple FVB driver with FV header.
-
-**/
-#include "FileIo.h"
-#include "FlashLayout.h"
-
-typedef struct {
-  UINT64                      FvLength;
-  EFI_FIRMWARE_VOLUME_HEADER  FvbInfo;
-  EFI_FV_BLOCK_MAP_ENTRY      End;
-} EFI_FVB_MEDIA_INFO;
-
-#define FVB_MEDIA_BLOCK_SIZE    FIRMWARE_BLOCK_SIZE
-#define RECOVERY_BOIS_BLOCK_NUM FIRMWARE_BLOCK_NUMBER
-#define SYSTEM_NV_BLOCK_NUM     2
-
-EFI_FVB_MEDIA_INFO  mPlatformFvbMediaInfo[] = {
-  //
-  // Systen NvStorage FVB
-  //
-  {
-    NV_STORAGE_FVB_SIZE,
-    {
-      {
-        0,
-      },  // ZeroVector[16]
-      EFI_SYSTEM_NV_DATA_FV_GUID,
-      NV_STORAGE_FVB_SIZE,
-      EFI_FVH_SIGNATURE,
-      EFI_FVB2_READ_ENABLED_CAP |
-        EFI_FVB2_READ_STATUS |
-        EFI_FVB2_WRITE_ENABLED_CAP |
-        EFI_FVB2_WRITE_STATUS |
-        EFI_FVB2_ERASE_POLARITY,
-      sizeof (EFI_FIRMWARE_VOLUME_HEADER) + sizeof (EFI_FV_BLOCK_MAP_ENTRY),
-      0,  // CheckSum
-      0,  // ExtHeaderOffset
-      {
-        0,
-      },  // Reserved[1]
-      1,  // Revision
-      {
-        NV_STORAGE_FVB_BLOCK_NUM,
-        FV_BLOCK_SIZE,
-      }
-    },
-    {
-      0,
-      0
-    }
-  },
-  //
-  // System FTW FVB
-  //
-  {
-    NV_FTW_FVB_SIZE,
-    {
-      {
-        0,
-      },  // ZeroVector[16]
-      EFI_SYSTEM_NV_DATA_FV_GUID,
-      NV_FTW_FVB_SIZE,
-      EFI_FVH_SIGNATURE,
-      EFI_FVB2_READ_ENABLED_CAP |
-        EFI_FVB2_READ_STATUS |
-        EFI_FVB2_WRITE_ENABLED_CAP |
-        EFI_FVB2_WRITE_STATUS |
-        EFI_FVB2_ERASE_POLARITY,
-      sizeof (EFI_FIRMWARE_VOLUME_HEADER) + sizeof (EFI_FV_BLOCK_MAP_ENTRY),
-      0,  // CheckSum
-      0,  // ExtHeaderOffset
-      {
-        0,
-      },  // Reserved[1]
-      1,  // Revision
-      {
-        NV_FTW_FVB_BLOCK_NUM,
-        FV_BLOCK_SIZE,
-      }
-    },
-    {
-      0,
-      0
-    }
-  }
-};
-
-EFI_STATUS
-GetFvbInfo (
-  IN  UINT64                        FvLength,
-  OUT EFI_FIRMWARE_VOLUME_HEADER    **FvbInfo
-  )
-{
-  UINTN Index;
-
-  for (Index = 0; Index < sizeof (mPlatformFvbMediaInfo) / sizeof (EFI_FVB_MEDIA_INFO); Index += 1) {
-    if (mPlatformFvbMediaInfo[Index].FvLength == FvLength) {
-      *FvbInfo = &mPlatformFvbMediaInfo[Index].FvbInfo;
-      return EFI_SUCCESS;
-    }
-  }
-
-  return EFI_NOT_FOUND;
-}
Index: DuetPkg/FvbRuntimeService/FwBlockService.h
===================================================================
--- DuetPkg/FvbRuntimeService/FwBlockService.h	(revision 1)
+++ DuetPkg/FvbRuntimeService/FwBlockService.h	(working copy)
@@ -1,298 +0,0 @@
-/**@file
-Copyright (c) 2007, Intel Corporation. All rights reserved.<BR>
-This program and the accompanying materials                          
-are licensed and made available under the terms and conditions of the BSD License         
-which accompanies this distribution.  The full text of the license may be found at        
-http://opensource.org/licenses/bsd-license.php                                            
-                                                                                          
-THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,                     
-WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.             
-
-Module Name:
-
-  FwBlockService.h
-  
-Abstract:
-
-  Firmware volume block driver for Intel Firmware Hub (FWH) device
-
-**/
-#ifndef _FW_BLOCK_SERVICE_H
-#define _FW_BLOCK_SERVICE_H
-
-//
-// The package level header files this module uses
-//
-#include <PiDxe.h>
-
-//
-// The protocols, PPI and GUID defintions for this module
-//
-#include <Guid/EventGroup.h>
-#include <Guid/FirmwareFileSystem2.h>
-#include <Protocol/FirmwareVolumeBlock.h>
-#include <Protocol/DevicePath.h>
-#include <Protocol/SimpleFileSystem.h>
-#include <Protocol/BlockIo.h>
-#include <Library/DevicePathLib.h>
-#include <Guid/SystemNvDataGuid.h>
-#include <Guid/FlashMapHob.h>
-#include <Guid/HobList.h>
-
-//
-// The Library classes this module consumes
-//
-#include <Library/UefiLib.h>
-#include <Library/UefiDriverEntryPoint.h>
-#include <Library/BaseLib.h>
-#include <Library/DxeServicesTableLib.h>
-#include <Library/UefiRuntimeLib.h>
-#include <Library/DebugLib.h>
-#include <Library/HobLib.h>
-#include <Library/BaseMemoryLib.h>
-#include <Library/MemoryAllocationLib.h>
-#include <Library/UefiBootServicesTableLib.h>
-#include <Library/PcdLib.h>
-
-
-#define FWH_READ_LOCK                   (1 << 2)
-#define FWH_LOCK_DOWN                   (1 << 1)
-#define FWH_WRITE_LOCK                  1
-#define FWH_WRITE_STATE_STATUS          (1 << 7)
-#define FWH_ERASE_STATUS                (1 << 5)
-#define FWH_PROGRAM_STATUS              (1 << 4)
-#define FWH_VPP_STATUS                  (1 << 3)
-#define STALL_TIME                      5
-#define FWH_ERASE_STATUS_BITS           (FWH_ERASE_STATUS || FWH_VPP_STATUS)
-#define FWH_WRITE_STATUS_BITS           (FWH_WRITE_STATUS || FWH_VPP_STATUS)
-
-//
-// BugBug: Add documentation here for data structure!!!!
-//
-#define FVB_PHYSICAL  0
-#define FVB_VIRTUAL   1
-
-#define EFI_FVB2_CAPABILITIES (EFI_FVB2_READ_DISABLED_CAP | \
-                              EFI_FVB2_READ_ENABLED_CAP | \
-                              EFI_FVB2_WRITE_DISABLED_CAP | \
-                              EFI_FVB2_WRITE_ENABLED_CAP | \
-                              EFI_FVB2_LOCK_CAP \
-                              )
-#define EFI_FVB2_STATUS (EFI_FVB2_READ_STATUS | EFI_FVB2_WRITE_STATUS | EFI_FVB2_LOCK_STATUS)
-
-typedef struct {
-  EFI_LOCK                    FvbDevLock;
-  UINTN                       FvBase[2];
-  //
-  // We can treat VolumeSignature combined with MappedFile 
-  //  as a unique key to locate the mapped file.
-#define MAX_PATH 256
-  UINT32                      VolumeId;
-  CHAR16                      MappedFile[MAX_PATH];
-  UINT32                      ActuralSize;
-  UINT32                      Offset;
-  
-  EFI_DEVICE_PATH_PROTOCOL    *Device; // only used in BS period, won't use after memory map changed
-  UINTN                       NumOfBlocks;
-  BOOLEAN                     WriteEnabled;
-  EFI_FIRMWARE_VOLUME_HEADER  VolumeHeader;
-} EFI_FW_VOL_INSTANCE;
-
-typedef struct {
-  UINT32              NumFv;
-  EFI_FW_VOL_INSTANCE *FvInstance[2];
-  UINT8               *FvbScratchSpace[2];
-} ESAL_FWB_GLOBAL;
-
-//
-// Fvb Protocol instance data
-//
-#define FVB_DEVICE_FROM_THIS(a)         CR (a, EFI_FW_VOL_BLOCK_DEVICE, FwVolBlockInstance, FVB_DEVICE_SIGNATURE)
-#define FVB_EXTEND_DEVICE_FROM_THIS(a)  CR (a, EFI_FW_VOL_BLOCK_DEVICE, FvbExtension, FVB_DEVICE_SIGNATURE)
-#define FVB_DEVICE_SIGNATURE            SIGNATURE_32 ('F', 'V', 'B', 'C')
-
-typedef struct {
-  MEMMAP_DEVICE_PATH        MemMapDevPath;
-  EFI_DEVICE_PATH_PROTOCOL  EndDevPath;
-} FV_DEVICE_PATH;
-
-typedef struct {
-  UINTN                               Signature;
-  FV_DEVICE_PATH                      DevicePath;
-  UINTN                               Instance;
-  EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL  FwVolBlockInstance;
-} EFI_FW_VOL_BLOCK_DEVICE;
-
-EFI_STATUS
-GetFvbInfo (
-  IN  EFI_PHYSICAL_ADDRESS              FvBaseAddress,
-  OUT EFI_FIRMWARE_VOLUME_HEADER        **FvbInfo
-  );
-
-EFI_STATUS
-EnableFvbWrites (
-  IN  BOOLEAN   EnableWrites
-  );
-
-EFI_STATUS
-PlatformGetFvbWriteBase (
-  IN  UINTN     CurrentBaseAddress,
-  IN  UINTN     *NewBaseAddress,
-  IN  BOOLEAN   *WriteEnabled
-  );
-
-EFI_STATUS
-EnablePlatformFvb (
-  VOID
-  );
-
-BOOLEAN
-SetPlatformFvbLock (
-  IN UINTN  LbaAddress
-  );
-
-EFI_STATUS
-FvbReadBlock (
-  IN UINTN                                Instance,
-  IN EFI_LBA                              Lba,
-  IN UINTN                                BlockOffset,
-  IN OUT UINTN                            *NumBytes,
-  IN UINT8                                *Buffer,
-  IN ESAL_FWB_GLOBAL                      *Global,
-  IN BOOLEAN                              Virtual
-  );
-
-EFI_STATUS
-FvbWriteBlock (
-  IN UINTN                                Instance,
-  IN EFI_LBA                              Lba,
-  IN UINTN                                BlockOffset,
-  IN OUT UINTN                            *NumBytes,
-  IN UINT8                                *Buffer,
-  IN ESAL_FWB_GLOBAL                      *Global,
-  IN BOOLEAN                              Virtual
-  );
-
-EFI_STATUS
-FvbEraseBlock (
-  IN UINTN                                Instance,
-  IN EFI_LBA                              Lba,
-  IN ESAL_FWB_GLOBAL                      *Global,
-  IN BOOLEAN                              Virtual
-  );
-
-EFI_STATUS
-FvbSetVolumeAttributes (
-  IN UINTN                                Instance,
-  IN OUT EFI_FVB_ATTRIBUTES_2             *Attributes,
-  IN ESAL_FWB_GLOBAL                      *Global,
-  IN BOOLEAN                              Virtual
-  );
-
-EFI_STATUS
-FvbGetVolumeAttributes (
-  IN UINTN                                Instance,
-  OUT EFI_FVB_ATTRIBUTES_2                *Attributes,
-  IN ESAL_FWB_GLOBAL                      *Global,
-  IN BOOLEAN                              Virtual
-  );
-
-EFI_STATUS
-FvbGetPhysicalAddress (
-  IN UINTN                                Instance,
-  OUT EFI_PHYSICAL_ADDRESS                *Address,
-  IN ESAL_FWB_GLOBAL                      *Global,
-  IN BOOLEAN                              Virtual
-  );
-
-EFI_STATUS
-EFIAPI
-FvbInitialize (
-  IN EFI_HANDLE         ImageHandle,
-  IN EFI_SYSTEM_TABLE   *SystemTable
-  );
-
-VOID
-EFIAPI
-FvbClassAddressChangeEvent (
-  IN EFI_EVENT        Event,
-  IN VOID             *Context
-  );
-
-EFI_STATUS
-FvbSpecificInitialize (
-  IN  ESAL_FWB_GLOBAL   *mFvbModuleGlobal
-  );
-
-EFI_STATUS
-FvbGetLbaAddress (
-  IN  UINTN                               Instance,
-  IN  EFI_LBA                             Lba,
-  OUT UINTN                               *LbaAddress,
-  OUT UINTN                               *LbaLength,
-  OUT UINTN                               *NumOfBlocks,
-  IN  ESAL_FWB_GLOBAL                     *Global,
-  IN  BOOLEAN                             Virtual
-  );
-
-//
-// Protocol APIs
-//
-EFI_STATUS
-EFIAPI
-FvbProtocolGetAttributes (
-  IN CONST EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL          *This,
-  OUT      EFI_FVB_ATTRIBUTES_2                        *Attributes
-  );
-
-EFI_STATUS
-EFIAPI
-FvbProtocolSetAttributes (
-  IN CONST EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL       *This,
-  IN OUT   EFI_FVB_ATTRIBUTES_2                     *Attributes
-  );
-
-EFI_STATUS
-EFIAPI
-FvbProtocolGetPhysicalAddress (
-  IN  CONST EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL          *This,
-  OUT       EFI_PHYSICAL_ADDRESS                        *Address
-  );
-
-EFI_STATUS
-EFIAPI
-FvbProtocolGetBlockSize (
-  IN CONST EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL           *This,
-  IN  EFI_LBA                                     Lba,
-  OUT UINTN                                       *BlockSize,
-  OUT UINTN                                       *NumOfBlocks
-  );
-
-EFI_STATUS
-EFIAPI
-FvbProtocolRead (
-  IN CONST EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL     *This,
-  IN EFI_LBA                                      Lba,
-  IN UINTN                                        Offset,
-  IN OUT UINTN                                    *NumBytes,
-  IN UINT8                                        *Buffer
-  );
-
-EFI_STATUS
-EFIAPI
-FvbProtocolWrite (
-  IN CONST EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL     *This,
-  IN EFI_LBA                                      Lba,
-  IN UINTN                                        Offset,
-  IN OUT UINTN                                    *NumBytes,
-  IN UINT8                                        *Buffer
-  );
-
-EFI_STATUS
-EFIAPI
-FvbProtocolEraseBlocks (
-  IN CONST EFI_FIRMWARE_VOLUME_BLOCK_PROTOCOL    *This,
-  ...  
-  );
-
-#endif
Index: DuetPkg/Include/Library/PlatformFvbLib.h
===================================================================
--- DuetPkg/Include/Library/PlatformFvbLib.h	(revision 0)
+++ DuetPkg/Include/Library/PlatformFvbLib.h	(working copy)
@@ -0,0 +1,87 @@
+/** @file
+  Library to define platform customization functions for a
+  Firmare Volume Block driver.
+
+  Copyright (c) 2009 - 2011, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef __PLATFORM_FVB_LIB__
+#define __PLATFORM_FVB_LIB__
+
+#include <Protocol/FirmwareVolumeBlock.h>
+
+/**
+  This function will be called following a call to the
+  EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL Read function.
+
+  @param[in] This     The EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL instance.
+  @param[in] Lba      The starting logical block index
+                      from which to read.
+  @param[in] Offset   Offset into the block at which to begin reading.
+  @param[in] NumBytes The number of bytes read.
+  @param[in] Buffer   Pointer to the buffer that was read, and will be
+                      returned to the caller.
+
+**/
+VOID
+EFIAPI
+PlatformFvbDataRead (
+  IN CONST  EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL *This,
+  IN        EFI_LBA                             Lba,
+  IN        UINTN                               Offset,
+  IN        UINTN                               NumBytes,
+  IN        UINT8                               *Buffer
+  );
+
+
+/**
+  This function will be called following a call to the
+  EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL Write function.
+
+  @param[in] This     EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL instance.
+  @param[in] Lba      The starting logical block index to written to.
+  @param[in] Offset   Offset into the block at which to begin writing.
+  @param[in] NumBytes The number of bytes written.
+  @param[in] Buffer   Pointer to the buffer that was written.
+
+**/
+VOID
+EFIAPI
+PlatformFvbDataWritten (
+  IN CONST  EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL  *This,
+  IN        EFI_LBA                              Lba,
+  IN        UINTN                                Offset,
+  IN        UINTN                                NumBytes,
+  IN        UINT8                                *Buffer
+  );
+
+
+/**
+  This function will be called following a call to the
+  EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL Erase function.
+
+  @param This   Indicates the EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL
+                instance.
+  @param List   The variable argument list as documented for
+                the EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL Erase
+                function.
+
+**/
+VOID
+EFIAPI
+PlatformFvbBlocksErased (
+  IN CONST  EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL *This,
+  IN  VA_LIST       List
+  );
+
+
+#endif
+
Index: DuetPkg/Library/EmuVariableFvbLib/EmuVariableFvbLib.c
===================================================================
--- DuetPkg/Library/EmuVariableFvbLib/EmuVariableFvbLib.c	(revision 0)
+++ DuetPkg/Library/EmuVariableFvbLib/EmuVariableFvbLib.c	(working copy)
@@ -0,0 +1,103 @@
+/** @file
+  Duet platform customization for EMU Variable FVB driver
+
+  Copyright (c) 2009 - 2011, Intel Corporation. All rights reserved.<BR>
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include "PiDxe.h"
+#include <Library/DebugLib.h>
+#include <Library/PcdLib.h>
+#include <Library/PlatformFvbLib.h>
+#include <Library/UefiBootServicesTableLib.h>
+#include <Library/UefiRuntimeLib.h>
+
+
+/**
+  This function will be called following a call to the
+  EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL Read function.
+
+  @param[in] This     The EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL instance.
+  @param[in] Lba      The starting logical block index
+                      from which to read.
+  @param[in] Offset   Offset into the block at which to begin reading.
+  @param[in] NumBytes The number of bytes read.
+  @param[in] Buffer   Pointer to the buffer that was read, and will be
+                      returned to the caller.
+
+**/
+VOID
+EFIAPI
+PlatformFvbDataRead (
+  IN CONST  EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL *This,
+  IN        EFI_LBA                             Lba,
+  IN        UINTN                               Offset,
+  IN        UINTN                               NumBytes,
+  IN        UINT8                               *Buffer
+  )
+{
+}
+
+
+/**
+  This function will be called following a call to the
+  EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL Write function.
+
+  @param[in] This     EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL instance.
+  @param[in] Lba      The starting logical block index to written to.
+  @param[in] Offset   Offset into the block at which to begin writing.
+  @param[in] NumBytes The number of bytes written.
+  @param[in] Buffer   Pointer to the buffer that was written.
+
+**/
+VOID
+EFIAPI
+PlatformFvbDataWritten (
+  IN CONST  EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL *This,
+  IN        EFI_LBA                             Lba,
+  IN        UINTN                               Offset,
+  IN        UINTN                               NumBytes,
+  IN        UINT8                               *Buffer
+  )
+{
+  STATIC EFI_EVENT EventToSignal = NULL;
+
+  if (!EfiAtRuntime ()) {
+    if (EventToSignal == NULL) {
+      EventToSignal = (EFI_EVENT)(UINTN) PcdGet64 (PcdEmuVariableEvent);
+    }
+    if (EventToSignal != NULL) {
+      gBS->SignalEvent (EventToSignal);
+    }
+  }
+}
+
+
+/**
+  This function will be called following a call to the
+  EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL Erase function.
+
+  @param This   Indicates the EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL
+                instance.
+  @param List   The variable argument list as documented for
+                the EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL Erase
+                function.
+
+**/
+VOID
+EFIAPI
+PlatformFvbBlocksErased (
+  IN CONST  EFI_FIRMWARE_VOLUME_BLOCK2_PROTOCOL *This,
+  IN  VA_LIST       List
+  )
+{
+}
+
+
Index: DuetPkg/Library/EmuVariableFvbLib/EmuVariableFvbLib.inf
===================================================================
--- DuetPkg/Library/EmuVariableFvbLib/EmuVariableFvbLib.inf	(revision 0)
+++ DuetPkg/Library/EmuVariableFvbLib/EmuVariableFvbLib.inf	(working copy)
@@ -0,0 +1,48 @@
+## @file
+#  Duet platform customization for EMU Variable FVB driver
+#
+#  This library handles hooks for the EMU Variable FVB driver.
+#
+#  Copyright (c) 2006 - 2010, Intel Corporation. All rights reserved.<BR>
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution. The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = EmuVariableFvbLib
+  FILE_GUID                      = 8a6062ed-7140-4a74-b4ea-fe900e79e24b
+  MODULE_TYPE                    = BASE
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = PlatformFvbLib|DXE_RUNTIME_DRIVER
+
+#
+# The following information is for reference only and not required by the build tools.
+#
+#  VALID_ARCHITECTURES           = IA32 X64 IPF EBC
+#
+
+[Sources]
+  EmuVariableFvbLib.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  MdeModulePkg/MdeModulePkg.dec
+  DuetPkg/DuetPkg.dec
+
+[LibraryClasses]
+  BaseLib
+  BaseMemoryLib
+  DebugLib
+  MemoryAllocationLib
+
+[Pcd]
+  gUefiDuetPkgTokenSpaceGuid.PcdEmuVariableEvent
+
